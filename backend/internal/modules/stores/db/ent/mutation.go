// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"waterfall-backend/internal/models"
	"waterfall-backend/internal/models/files"
	"waterfall-backend/internal/models/permissions"
	"waterfall-backend/internal/models/roles"
	"waterfall-backend/internal/modules/stores/db/ent/chapter"
	"waterfall-backend/internal/modules/stores/db/ent/chaptertext"
	"waterfall-backend/internal/modules/stores/db/ent/comment"
	"waterfall-backend/internal/modules/stores/db/ent/file"
	"waterfall-backend/internal/modules/stores/db/ent/migrations"
	"waterfall-backend/internal/modules/stores/db/ent/part"
	"waterfall-backend/internal/modules/stores/db/ent/permission"
	"waterfall-backend/internal/modules/stores/db/ent/predicate"
	"waterfall-backend/internal/modules/stores/db/ent/release"
	"waterfall-backend/internal/modules/stores/db/ent/role"
	"waterfall-backend/internal/modules/stores/db/ent/seedmigrations"
	"waterfall-backend/internal/modules/stores/db/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChapter        = "Chapter"
	TypeChapterText    = "ChapterText"
	TypeComment        = "Comment"
	TypeFile           = "File"
	TypeMigrations     = "Migrations"
	TypePart           = "Part"
	TypePermission     = "Permission"
	TypeRelease        = "Release"
	TypeRole           = "Role"
	TypeSeedMigrations = "SeedMigrations"
	TypeUser           = "User"
)

// ChapterMutation represents an operation that mutates the Chapter nodes in the graph.
type ChapterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	number              *int
	addnumber           *int
	title               *string
	clearedFields       map[string]struct{}
	part                *string
	clearedpart         bool
	release             *string
	clearedrelease      bool
	comments            map[string]struct{}
	removedcomments     map[string]struct{}
	clearedcomments     bool
	chapter_text        *string
	clearedchapter_text bool
	done                bool
	oldValue            func(context.Context) (*Chapter, error)
	predicates          []predicate.Chapter
}

var _ ent.Mutation = (*ChapterMutation)(nil)

// chapterOption allows management of the mutation configuration using functional options.
type chapterOption func(*ChapterMutation)

// newChapterMutation creates new mutation for the Chapter entity.
func newChapterMutation(c config, op Op, opts ...chapterOption) *ChapterMutation {
	m := &ChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChapterID sets the ID field of the mutation.
func withChapterID(id string) chapterOption {
	return func(m *ChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Chapter
		)
		m.oldValue = func(ctx context.Context) (*Chapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChapter sets the old Chapter of the mutation.
func withChapter(node *Chapter) chapterOption {
	return func(m *ChapterMutation) {
		m.oldValue = func(context.Context) (*Chapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chapter entities.
func (m *ChapterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChapterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChapterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChapterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChapterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChapterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChapterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChapterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChapterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChapterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChapterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChapterMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[chapter.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChapterMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[chapter.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChapterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, chapter.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *ChapterMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *ChapterMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *ChapterMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *ChapterMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *ChapterMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[chapter.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *ChapterMutation) NumberCleared() bool {
	_, ok := m.clearedFields[chapter.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *ChapterMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, chapter.FieldNumber)
}

// SetTitle sets the "title" field.
func (m *ChapterMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChapterMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChapterMutation) ResetTitle() {
	m.title = nil
}

// SetPartUUID sets the "part_uuid" field.
func (m *ChapterMutation) SetPartUUID(s string) {
	m.part = &s
}

// PartUUID returns the value of the "part_uuid" field in the mutation.
func (m *ChapterMutation) PartUUID() (r string, exists bool) {
	v := m.part
	if v == nil {
		return
	}
	return *v, true
}

// OldPartUUID returns the old "part_uuid" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldPartUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartUUID: %w", err)
	}
	return oldValue.PartUUID, nil
}

// ResetPartUUID resets all changes to the "part_uuid" field.
func (m *ChapterMutation) ResetPartUUID() {
	m.part = nil
}

// SetReleaseUUID sets the "release_uuid" field.
func (m *ChapterMutation) SetReleaseUUID(s string) {
	m.release = &s
}

// ReleaseUUID returns the value of the "release_uuid" field in the mutation.
func (m *ChapterMutation) ReleaseUUID() (r string, exists bool) {
	v := m.release
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseUUID returns the old "release_uuid" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldReleaseUUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseUUID: %w", err)
	}
	return oldValue.ReleaseUUID, nil
}

// ClearReleaseUUID clears the value of the "release_uuid" field.
func (m *ChapterMutation) ClearReleaseUUID() {
	m.release = nil
	m.clearedFields[chapter.FieldReleaseUUID] = struct{}{}
}

// ReleaseUUIDCleared returns if the "release_uuid" field was cleared in this mutation.
func (m *ChapterMutation) ReleaseUUIDCleared() bool {
	_, ok := m.clearedFields[chapter.FieldReleaseUUID]
	return ok
}

// ResetReleaseUUID resets all changes to the "release_uuid" field.
func (m *ChapterMutation) ResetReleaseUUID() {
	m.release = nil
	delete(m.clearedFields, chapter.FieldReleaseUUID)
}

// SetPartID sets the "part" edge to the Part entity by id.
func (m *ChapterMutation) SetPartID(id string) {
	m.part = &id
}

// ClearPart clears the "part" edge to the Part entity.
func (m *ChapterMutation) ClearPart() {
	m.clearedpart = true
}

// PartCleared reports if the "part" edge to the Part entity was cleared.
func (m *ChapterMutation) PartCleared() bool {
	return m.clearedpart
}

// PartID returns the "part" edge ID in the mutation.
func (m *ChapterMutation) PartID() (id string, exists bool) {
	if m.part != nil {
		return *m.part, true
	}
	return
}

// PartIDs returns the "part" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) PartIDs() (ids []string) {
	if id := m.part; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPart resets all changes to the "part" edge.
func (m *ChapterMutation) ResetPart() {
	m.part = nil
	m.clearedpart = false
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *ChapterMutation) SetReleaseID(id string) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *ChapterMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *ChapterMutation) ReleaseCleared() bool {
	return m.ReleaseUUIDCleared() || m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *ChapterMutation) ReleaseID() (id string, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) ReleaseIDs() (ids []string) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *ChapterMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ChapterMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ChapterMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ChapterMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ChapterMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ChapterMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ChapterMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ChapterMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// SetChapterTextID sets the "chapter_text" edge to the ChapterText entity by id.
func (m *ChapterMutation) SetChapterTextID(id string) {
	m.chapter_text = &id
}

// ClearChapterText clears the "chapter_text" edge to the ChapterText entity.
func (m *ChapterMutation) ClearChapterText() {
	m.clearedchapter_text = true
}

// ChapterTextCleared reports if the "chapter_text" edge to the ChapterText entity was cleared.
func (m *ChapterMutation) ChapterTextCleared() bool {
	return m.clearedchapter_text
}

// ChapterTextID returns the "chapter_text" edge ID in the mutation.
func (m *ChapterMutation) ChapterTextID() (id string, exists bool) {
	if m.chapter_text != nil {
		return *m.chapter_text, true
	}
	return
}

// ChapterTextIDs returns the "chapter_text" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterTextID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) ChapterTextIDs() (ids []string) {
	if id := m.chapter_text; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapterText resets all changes to the "chapter_text" edge.
func (m *ChapterMutation) ResetChapterText() {
	m.chapter_text = nil
	m.clearedchapter_text = false
}

// Where appends a list predicates to the ChapterMutation builder.
func (m *ChapterMutation) Where(ps ...predicate.Chapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chapter).
func (m *ChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChapterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, chapter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chapter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, chapter.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, chapter.FieldNumber)
	}
	if m.title != nil {
		fields = append(fields, chapter.FieldTitle)
	}
	if m.part != nil {
		fields = append(fields, chapter.FieldPartUUID)
	}
	if m.release != nil {
		fields = append(fields, chapter.FieldReleaseUUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldCreatedAt:
		return m.CreatedAt()
	case chapter.FieldUpdatedAt:
		return m.UpdatedAt()
	case chapter.FieldDeletedAt:
		return m.DeletedAt()
	case chapter.FieldNumber:
		return m.Number()
	case chapter.FieldTitle:
		return m.Title()
	case chapter.FieldPartUUID:
		return m.PartUUID()
	case chapter.FieldReleaseUUID:
		return m.ReleaseUUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chapter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chapter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chapter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case chapter.FieldNumber:
		return m.OldNumber(ctx)
	case chapter.FieldTitle:
		return m.OldTitle(ctx)
	case chapter.FieldPartUUID:
		return m.OldPartUUID(ctx)
	case chapter.FieldReleaseUUID:
		return m.OldReleaseUUID(ctx)
	}
	return nil, fmt.Errorf("unknown Chapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chapter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chapter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case chapter.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case chapter.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case chapter.FieldPartUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartUUID(v)
		return nil
	case chapter.FieldReleaseUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseUUID(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChapterMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, chapter.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chapter.FieldDeletedAt) {
		fields = append(fields, chapter.FieldDeletedAt)
	}
	if m.FieldCleared(chapter.FieldNumber) {
		fields = append(fields, chapter.FieldNumber)
	}
	if m.FieldCleared(chapter.FieldReleaseUUID) {
		fields = append(fields, chapter.FieldReleaseUUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChapterMutation) ClearField(name string) error {
	switch name {
	case chapter.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case chapter.FieldNumber:
		m.ClearNumber()
		return nil
	case chapter.FieldReleaseUUID:
		m.ClearReleaseUUID()
		return nil
	}
	return fmt.Errorf("unknown Chapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChapterMutation) ResetField(name string) error {
	switch name {
	case chapter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chapter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chapter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case chapter.FieldNumber:
		m.ResetNumber()
		return nil
	case chapter.FieldTitle:
		m.ResetTitle()
		return nil
	case chapter.FieldPartUUID:
		m.ResetPartUUID()
		return nil
	case chapter.FieldReleaseUUID:
		m.ResetReleaseUUID()
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.part != nil {
		edges = append(edges, chapter.EdgePart)
	}
	if m.release != nil {
		edges = append(edges, chapter.EdgeRelease)
	}
	if m.comments != nil {
		edges = append(edges, chapter.EdgeComments)
	}
	if m.chapter_text != nil {
		edges = append(edges, chapter.EdgeChapterText)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgePart:
		if id := m.part; id != nil {
			return []ent.Value{*id}
		}
	case chapter.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	case chapter.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case chapter.EdgeChapterText:
		if id := m.chapter_text; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomments != nil {
		edges = append(edges, chapter.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpart {
		edges = append(edges, chapter.EdgePart)
	}
	if m.clearedrelease {
		edges = append(edges, chapter.EdgeRelease)
	}
	if m.clearedcomments {
		edges = append(edges, chapter.EdgeComments)
	}
	if m.clearedchapter_text {
		edges = append(edges, chapter.EdgeChapterText)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case chapter.EdgePart:
		return m.clearedpart
	case chapter.EdgeRelease:
		return m.clearedrelease
	case chapter.EdgeComments:
		return m.clearedcomments
	case chapter.EdgeChapterText:
		return m.clearedchapter_text
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChapterMutation) ClearEdge(name string) error {
	switch name {
	case chapter.EdgePart:
		m.ClearPart()
		return nil
	case chapter.EdgeRelease:
		m.ClearRelease()
		return nil
	case chapter.EdgeChapterText:
		m.ClearChapterText()
		return nil
	}
	return fmt.Errorf("unknown Chapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChapterMutation) ResetEdge(name string) error {
	switch name {
	case chapter.EdgePart:
		m.ResetPart()
		return nil
	case chapter.EdgeRelease:
		m.ResetRelease()
		return nil
	case chapter.EdgeComments:
		m.ResetComments()
		return nil
	case chapter.EdgeChapterText:
		m.ResetChapterText()
		return nil
	}
	return fmt.Errorf("unknown Chapter edge %s", name)
}

// ChapterTextMutation represents an operation that mutates the ChapterText nodes in the graph.
type ChapterTextMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	text           *string
	clearedFields  map[string]struct{}
	chapter        *string
	clearedchapter bool
	done           bool
	oldValue       func(context.Context) (*ChapterText, error)
	predicates     []predicate.ChapterText
}

var _ ent.Mutation = (*ChapterTextMutation)(nil)

// chaptertextOption allows management of the mutation configuration using functional options.
type chaptertextOption func(*ChapterTextMutation)

// newChapterTextMutation creates new mutation for the ChapterText entity.
func newChapterTextMutation(c config, op Op, opts ...chaptertextOption) *ChapterTextMutation {
	m := &ChapterTextMutation{
		config:        c,
		op:            op,
		typ:           TypeChapterText,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChapterTextID sets the ID field of the mutation.
func withChapterTextID(id string) chaptertextOption {
	return func(m *ChapterTextMutation) {
		var (
			err   error
			once  sync.Once
			value *ChapterText
		)
		m.oldValue = func(ctx context.Context) (*ChapterText, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChapterText.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChapterText sets the old ChapterText of the mutation.
func withChapterText(node *ChapterText) chaptertextOption {
	return func(m *ChapterTextMutation) {
		m.oldValue = func(context.Context) (*ChapterText, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChapterTextMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChapterTextMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChapterText entities.
func (m *ChapterTextMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChapterTextMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChapterTextMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChapterText.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChapterTextMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChapterTextMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChapterText entity.
// If the ChapterText object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterTextMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChapterTextMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChapterTextMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChapterTextMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChapterText entity.
// If the ChapterText object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterTextMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChapterTextMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChapterTextMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChapterTextMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ChapterText entity.
// If the ChapterText object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterTextMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChapterTextMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[chaptertext.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChapterTextMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[chaptertext.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChapterTextMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, chaptertext.FieldDeletedAt)
}

// SetChapterUUID sets the "chapter_uuid" field.
func (m *ChapterTextMutation) SetChapterUUID(s string) {
	m.chapter = &s
}

// ChapterUUID returns the value of the "chapter_uuid" field in the mutation.
func (m *ChapterTextMutation) ChapterUUID() (r string, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterUUID returns the old "chapter_uuid" field's value of the ChapterText entity.
// If the ChapterText object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterTextMutation) OldChapterUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterUUID: %w", err)
	}
	return oldValue.ChapterUUID, nil
}

// ResetChapterUUID resets all changes to the "chapter_uuid" field.
func (m *ChapterTextMutation) ResetChapterUUID() {
	m.chapter = nil
}

// SetText sets the "text" field.
func (m *ChapterTextMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *ChapterTextMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the ChapterText entity.
// If the ChapterText object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterTextMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *ChapterTextMutation) ResetText() {
	m.text = nil
}

// SetChapterID sets the "chapter" edge to the Chapter entity by id.
func (m *ChapterTextMutation) SetChapterID(id string) {
	m.chapter = &id
}

// ClearChapter clears the "chapter" edge to the Chapter entity.
func (m *ChapterTextMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the Chapter entity was cleared.
func (m *ChapterTextMutation) ChapterCleared() bool {
	return m.clearedchapter
}

// ChapterID returns the "chapter" edge ID in the mutation.
func (m *ChapterTextMutation) ChapterID() (id string, exists bool) {
	if m.chapter != nil {
		return *m.chapter, true
	}
	return
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *ChapterTextMutation) ChapterIDs() (ids []string) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *ChapterTextMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// Where appends a list predicates to the ChapterTextMutation builder.
func (m *ChapterTextMutation) Where(ps ...predicate.ChapterText) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChapterTextMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChapterTextMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChapterText, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChapterTextMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChapterTextMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChapterText).
func (m *ChapterTextMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChapterTextMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, chaptertext.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chaptertext.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, chaptertext.FieldDeletedAt)
	}
	if m.chapter != nil {
		fields = append(fields, chaptertext.FieldChapterUUID)
	}
	if m.text != nil {
		fields = append(fields, chaptertext.FieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChapterTextMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chaptertext.FieldCreatedAt:
		return m.CreatedAt()
	case chaptertext.FieldUpdatedAt:
		return m.UpdatedAt()
	case chaptertext.FieldDeletedAt:
		return m.DeletedAt()
	case chaptertext.FieldChapterUUID:
		return m.ChapterUUID()
	case chaptertext.FieldText:
		return m.Text()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChapterTextMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chaptertext.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chaptertext.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chaptertext.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case chaptertext.FieldChapterUUID:
		return m.OldChapterUUID(ctx)
	case chaptertext.FieldText:
		return m.OldText(ctx)
	}
	return nil, fmt.Errorf("unknown ChapterText field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterTextMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chaptertext.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chaptertext.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chaptertext.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case chaptertext.FieldChapterUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterUUID(v)
		return nil
	case chaptertext.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	}
	return fmt.Errorf("unknown ChapterText field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChapterTextMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChapterTextMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterTextMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChapterText numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChapterTextMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chaptertext.FieldDeletedAt) {
		fields = append(fields, chaptertext.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChapterTextMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChapterTextMutation) ClearField(name string) error {
	switch name {
	case chaptertext.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown ChapterText nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChapterTextMutation) ResetField(name string) error {
	switch name {
	case chaptertext.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chaptertext.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chaptertext.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case chaptertext.FieldChapterUUID:
		m.ResetChapterUUID()
		return nil
	case chaptertext.FieldText:
		m.ResetText()
		return nil
	}
	return fmt.Errorf("unknown ChapterText field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChapterTextMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chapter != nil {
		edges = append(edges, chaptertext.EdgeChapter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChapterTextMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chaptertext.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChapterTextMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChapterTextMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChapterTextMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchapter {
		edges = append(edges, chaptertext.EdgeChapter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChapterTextMutation) EdgeCleared(name string) bool {
	switch name {
	case chaptertext.EdgeChapter:
		return m.clearedchapter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChapterTextMutation) ClearEdge(name string) error {
	switch name {
	case chaptertext.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown ChapterText unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChapterTextMutation) ResetEdge(name string) error {
	switch name {
	case chaptertext.EdgeChapter:
		m.ResetChapter()
		return nil
	}
	return fmt.Errorf("unknown ChapterText edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	text            *string
	clearedFields   map[string]struct{}
	author          *string
	clearedauthor   bool
	parent          *string
	clearedparent   bool
	children        map[string]struct{}
	removedchildren map[string]struct{}
	clearedchildren bool
	chapter         *string
	clearedchapter  bool
	done            bool
	oldValue        func(context.Context) (*Comment, error)
	predicates      []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id string) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Comment entities.
func (m *CommentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[comment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, comment.FieldDeletedAt)
}

// SetText sets the "text" field.
func (m *CommentMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *CommentMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *CommentMutation) ResetText() {
	m.text = nil
}

// SetAuthorUUID sets the "author_uuid" field.
func (m *CommentMutation) SetAuthorUUID(s string) {
	m.author = &s
}

// AuthorUUID returns the value of the "author_uuid" field in the mutation.
func (m *CommentMutation) AuthorUUID() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorUUID returns the old "author_uuid" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldAuthorUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorUUID: %w", err)
	}
	return oldValue.AuthorUUID, nil
}

// ResetAuthorUUID resets all changes to the "author_uuid" field.
func (m *CommentMutation) ResetAuthorUUID() {
	m.author = nil
}

// SetParentUUID sets the "parent_uuid" field.
func (m *CommentMutation) SetParentUUID(s string) {
	m.parent = &s
}

// ParentUUID returns the value of the "parent_uuid" field in the mutation.
func (m *CommentMutation) ParentUUID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentUUID returns the old "parent_uuid" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentUUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentUUID: %w", err)
	}
	return oldValue.ParentUUID, nil
}

// ClearParentUUID clears the value of the "parent_uuid" field.
func (m *CommentMutation) ClearParentUUID() {
	m.parent = nil
	m.clearedFields[comment.FieldParentUUID] = struct{}{}
}

// ParentUUIDCleared returns if the "parent_uuid" field was cleared in this mutation.
func (m *CommentMutation) ParentUUIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentUUID]
	return ok
}

// ResetParentUUID resets all changes to the "parent_uuid" field.
func (m *CommentMutation) ResetParentUUID() {
	m.parent = nil
	delete(m.clearedFields, comment.FieldParentUUID)
}

// SetChapterUUID sets the "chapter_uuid" field.
func (m *CommentMutation) SetChapterUUID(s string) {
	m.chapter = &s
}

// ChapterUUID returns the value of the "chapter_uuid" field in the mutation.
func (m *CommentMutation) ChapterUUID() (r string, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterUUID returns the old "chapter_uuid" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldChapterUUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterUUID: %w", err)
	}
	return oldValue.ChapterUUID, nil
}

// ClearChapterUUID clears the value of the "chapter_uuid" field.
func (m *CommentMutation) ClearChapterUUID() {
	m.chapter = nil
	m.clearedFields[comment.FieldChapterUUID] = struct{}{}
}

// ChapterUUIDCleared returns if the "chapter_uuid" field was cleared in this mutation.
func (m *CommentMutation) ChapterUUIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldChapterUUID]
	return ok
}

// ResetChapterUUID resets all changes to the "chapter_uuid" field.
func (m *CommentMutation) ResetChapterUUID() {
	m.chapter = nil
	delete(m.clearedFields, comment.FieldChapterUUID)
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *CommentMutation) SetAuthorID(id string) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *CommentMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *CommentMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *CommentMutation) AuthorID() (id string, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) AuthorIDs() (ids []string) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *CommentMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetParentID sets the "parent" edge to the Comment entity by id.
func (m *CommentMutation) SetParentID(id string) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.ParentUUIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CommentMutation) ParentID() (id string, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Comment entity by ids.
func (m *CommentMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Comment entity.
func (m *CommentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Comment entity was cleared.
func (m *CommentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Comment entity.
func (m *CommentMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CommentMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CommentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetChapterID sets the "chapter" edge to the Chapter entity by id.
func (m *CommentMutation) SetChapterID(id string) {
	m.chapter = &id
}

// ClearChapter clears the "chapter" edge to the Chapter entity.
func (m *CommentMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the Chapter entity was cleared.
func (m *CommentMutation) ChapterCleared() bool {
	return m.ChapterUUIDCleared() || m.clearedchapter
}

// ChapterID returns the "chapter" edge ID in the mutation.
func (m *CommentMutation) ChapterID() (id string, exists bool) {
	if m.chapter != nil {
		return *m.chapter, true
	}
	return
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ChapterIDs() (ids []string) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *CommentMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, comment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.text != nil {
		fields = append(fields, comment.FieldText)
	}
	if m.author != nil {
		fields = append(fields, comment.FieldAuthorUUID)
	}
	if m.parent != nil {
		fields = append(fields, comment.FieldParentUUID)
	}
	if m.chapter != nil {
		fields = append(fields, comment.FieldChapterUUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	case comment.FieldUpdatedAt:
		return m.UpdatedAt()
	case comment.FieldDeletedAt:
		return m.DeletedAt()
	case comment.FieldText:
		return m.Text()
	case comment.FieldAuthorUUID:
		return m.AuthorUUID()
	case comment.FieldParentUUID:
		return m.ParentUUID()
	case comment.FieldChapterUUID:
		return m.ChapterUUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case comment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case comment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case comment.FieldText:
		return m.OldText(ctx)
	case comment.FieldAuthorUUID:
		return m.OldAuthorUUID(ctx)
	case comment.FieldParentUUID:
		return m.OldParentUUID(ctx)
	case comment.FieldChapterUUID:
		return m.OldChapterUUID(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case comment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case comment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case comment.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case comment.FieldAuthorUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorUUID(v)
		return nil
	case comment.FieldParentUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentUUID(v)
		return nil
	case comment.FieldChapterUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterUUID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldDeletedAt) {
		fields = append(fields, comment.FieldDeletedAt)
	}
	if m.FieldCleared(comment.FieldParentUUID) {
		fields = append(fields, comment.FieldParentUUID)
	}
	if m.FieldCleared(comment.FieldChapterUUID) {
		fields = append(fields, comment.FieldChapterUUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case comment.FieldParentUUID:
		m.ClearParentUUID()
		return nil
	case comment.FieldChapterUUID:
		m.ClearChapterUUID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case comment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case comment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case comment.FieldText:
		m.ResetText()
		return nil
	case comment.FieldAuthorUUID:
		m.ResetAuthorUUID()
		return nil
	case comment.FieldParentUUID:
		m.ResetParentUUID()
		return nil
	case comment.FieldChapterUUID:
		m.ResetChapterUUID()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.author != nil {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.chapter != nil {
		edges = append(edges, comment.EdgeChapter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedauthor {
		edges = append(edges, comment.EdgeAuthor)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.clearedchapter {
		edges = append(edges, comment.EdgeChapter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeAuthor:
		return m.clearedauthor
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeChildren:
		return m.clearedchildren
	case comment.EdgeChapter:
		return m.clearedchapter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case comment.EdgeParent:
		m.ClearParent()
		return nil
	case comment.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeChildren:
		m.ResetChildren()
		return nil
	case comment.EdgeChapter:
		m.ResetChapter()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	filename           *string
	mime_type          *string
	description        *string
	object_type        *models.ObjectType
	object_ref         *string
	_type              *files.Type
	temp               *bool
	sequence_number    *uint
	addsequence_number *int
	clearedFields      map[string]struct{}
	creator            *string
	clearedcreator     bool
	done               bool
	oldValue           func(context.Context) (*File, error)
	predicates         []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id string) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFilename sets the "filename" field.
func (m *FileMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *FileMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *FileMutation) ResetFilename() {
	m.filename = nil
}

// SetMimeType sets the "mime_type" field.
func (m *FileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *FileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *FileMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetDescription sets the "description" field.
func (m *FileMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FileMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FileMutation) ResetDescription() {
	m.description = nil
}

// SetCreatorUUID sets the "creator_uuid" field.
func (m *FileMutation) SetCreatorUUID(s string) {
	m.creator = &s
}

// CreatorUUID returns the value of the "creator_uuid" field in the mutation.
func (m *FileMutation) CreatorUUID() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorUUID returns the old "creator_uuid" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatorUUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorUUID: %w", err)
	}
	return oldValue.CreatorUUID, nil
}

// ClearCreatorUUID clears the value of the "creator_uuid" field.
func (m *FileMutation) ClearCreatorUUID() {
	m.creator = nil
	m.clearedFields[file.FieldCreatorUUID] = struct{}{}
}

// CreatorUUIDCleared returns if the "creator_uuid" field was cleared in this mutation.
func (m *FileMutation) CreatorUUIDCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatorUUID]
	return ok
}

// ResetCreatorUUID resets all changes to the "creator_uuid" field.
func (m *FileMutation) ResetCreatorUUID() {
	m.creator = nil
	delete(m.clearedFields, file.FieldCreatorUUID)
}

// SetObjectType sets the "object_type" field.
func (m *FileMutation) SetObjectType(mt models.ObjectType) {
	m.object_type = &mt
}

// ObjectType returns the value of the "object_type" field in the mutation.
func (m *FileMutation) ObjectType() (r models.ObjectType, exists bool) {
	v := m.object_type
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectType returns the old "object_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldObjectType(ctx context.Context) (v models.ObjectType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectType: %w", err)
	}
	return oldValue.ObjectType, nil
}

// ResetObjectType resets all changes to the "object_type" field.
func (m *FileMutation) ResetObjectType() {
	m.object_type = nil
}

// SetObjectRef sets the "object_ref" field.
func (m *FileMutation) SetObjectRef(s string) {
	m.object_ref = &s
}

// ObjectRef returns the value of the "object_ref" field in the mutation.
func (m *FileMutation) ObjectRef() (r string, exists bool) {
	v := m.object_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectRef returns the old "object_ref" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldObjectRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectRef: %w", err)
	}
	return oldValue.ObjectRef, nil
}

// ResetObjectRef resets all changes to the "object_ref" field.
func (m *FileMutation) ResetObjectRef() {
	m.object_ref = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f files.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r files.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v files.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetTemp sets the "temp" field.
func (m *FileMutation) SetTemp(b bool) {
	m.temp = &b
}

// Temp returns the value of the "temp" field in the mutation.
func (m *FileMutation) Temp() (r bool, exists bool) {
	v := m.temp
	if v == nil {
		return
	}
	return *v, true
}

// OldTemp returns the old "temp" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldTemp(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemp: %w", err)
	}
	return oldValue.Temp, nil
}

// ResetTemp resets all changes to the "temp" field.
func (m *FileMutation) ResetTemp() {
	m.temp = nil
}

// SetSequenceNumber sets the "sequence_number" field.
func (m *FileMutation) SetSequenceNumber(u uint) {
	m.sequence_number = &u
	m.addsequence_number = nil
}

// SequenceNumber returns the value of the "sequence_number" field in the mutation.
func (m *FileMutation) SequenceNumber() (r uint, exists bool) {
	v := m.sequence_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "sequence_number" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSequenceNumber(ctx context.Context) (v *uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds u to the "sequence_number" field.
func (m *FileMutation) AddSequenceNumber(u int) {
	if m.addsequence_number != nil {
		*m.addsequence_number += u
	} else {
		m.addsequence_number = &u
	}
}

// AddedSequenceNumber returns the value that was added to the "sequence_number" field in this mutation.
func (m *FileMutation) AddedSequenceNumber() (r int, exists bool) {
	v := m.addsequence_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNumber clears the value of the "sequence_number" field.
func (m *FileMutation) ClearSequenceNumber() {
	m.sequence_number = nil
	m.addsequence_number = nil
	m.clearedFields[file.FieldSequenceNumber] = struct{}{}
}

// SequenceNumberCleared returns if the "sequence_number" field was cleared in this mutation.
func (m *FileMutation) SequenceNumberCleared() bool {
	_, ok := m.clearedFields[file.FieldSequenceNumber]
	return ok
}

// ResetSequenceNumber resets all changes to the "sequence_number" field.
func (m *FileMutation) ResetSequenceNumber() {
	m.sequence_number = nil
	m.addsequence_number = nil
	delete(m.clearedFields, file.FieldSequenceNumber)
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *FileMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *FileMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *FileMutation) CreatorCleared() bool {
	return m.CreatorUUIDCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *FileMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *FileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.filename != nil {
		fields = append(fields, file.FieldFilename)
	}
	if m.mime_type != nil {
		fields = append(fields, file.FieldMimeType)
	}
	if m.description != nil {
		fields = append(fields, file.FieldDescription)
	}
	if m.creator != nil {
		fields = append(fields, file.FieldCreatorUUID)
	}
	if m.object_type != nil {
		fields = append(fields, file.FieldObjectType)
	}
	if m.object_ref != nil {
		fields = append(fields, file.FieldObjectRef)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.temp != nil {
		fields = append(fields, file.FieldTemp)
	}
	if m.sequence_number != nil {
		fields = append(fields, file.FieldSequenceNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldFilename:
		return m.Filename()
	case file.FieldMimeType:
		return m.MimeType()
	case file.FieldDescription:
		return m.Description()
	case file.FieldCreatorUUID:
		return m.CreatorUUID()
	case file.FieldObjectType:
		return m.ObjectType()
	case file.FieldObjectRef:
		return m.ObjectRef()
	case file.FieldType:
		return m.GetType()
	case file.FieldTemp:
		return m.Temp()
	case file.FieldSequenceNumber:
		return m.SequenceNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldFilename:
		return m.OldFilename(ctx)
	case file.FieldMimeType:
		return m.OldMimeType(ctx)
	case file.FieldDescription:
		return m.OldDescription(ctx)
	case file.FieldCreatorUUID:
		return m.OldCreatorUUID(ctx)
	case file.FieldObjectType:
		return m.OldObjectType(ctx)
	case file.FieldObjectRef:
		return m.OldObjectRef(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldTemp:
		return m.OldTemp(ctx)
	case file.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case file.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case file.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case file.FieldCreatorUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorUUID(v)
		return nil
	case file.FieldObjectType:
		v, ok := value.(models.ObjectType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectType(v)
		return nil
	case file.FieldObjectRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectRef(v)
		return nil
	case file.FieldType:
		v, ok := value.(files.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldTemp:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemp(v)
		return nil
	case file.FieldSequenceNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_number != nil {
		fields = append(fields, file.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSequenceNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldCreatorUUID) {
		fields = append(fields, file.FieldCreatorUUID)
	}
	if m.FieldCleared(file.FieldSequenceNumber) {
		fields = append(fields, file.FieldSequenceNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldCreatorUUID:
		m.ClearCreatorUUID()
		return nil
	case file.FieldSequenceNumber:
		m.ClearSequenceNumber()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldFilename:
		m.ResetFilename()
		return nil
	case file.FieldMimeType:
		m.ResetMimeType()
		return nil
	case file.FieldDescription:
		m.ResetDescription()
		return nil
	case file.FieldCreatorUUID:
		m.ResetCreatorUUID()
		return nil
	case file.FieldObjectType:
		m.ResetObjectType()
		return nil
	case file.FieldObjectRef:
		m.ResetObjectRef()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldTemp:
		m.ResetTemp()
		return nil
	case file.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.creator != nil {
		edges = append(edges, file.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcreator {
		edges = append(edges, file.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// MigrationsMutation represents an operation that mutates the Migrations nodes in the graph.
type MigrationsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	migrated      *int
	addmigrated   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Migrations, error)
	predicates    []predicate.Migrations
}

var _ ent.Mutation = (*MigrationsMutation)(nil)

// migrationsOption allows management of the mutation configuration using functional options.
type migrationsOption func(*MigrationsMutation)

// newMigrationsMutation creates new mutation for the Migrations entity.
func newMigrationsMutation(c config, op Op, opts ...migrationsOption) *MigrationsMutation {
	m := &MigrationsMutation{
		config:        c,
		op:            op,
		typ:           TypeMigrations,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMigrationsID sets the ID field of the mutation.
func withMigrationsID(id int) migrationsOption {
	return func(m *MigrationsMutation) {
		var (
			err   error
			once  sync.Once
			value *Migrations
		)
		m.oldValue = func(ctx context.Context) (*Migrations, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Migrations.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMigrations sets the old Migrations of the mutation.
func withMigrations(node *Migrations) migrationsOption {
	return func(m *MigrationsMutation) {
		m.oldValue = func(context.Context) (*Migrations, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MigrationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MigrationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MigrationsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MigrationsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Migrations.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMigrated sets the "migrated" field.
func (m *MigrationsMutation) SetMigrated(i int) {
	m.migrated = &i
	m.addmigrated = nil
}

// Migrated returns the value of the "migrated" field in the mutation.
func (m *MigrationsMutation) Migrated() (r int, exists bool) {
	v := m.migrated
	if v == nil {
		return
	}
	return *v, true
}

// OldMigrated returns the old "migrated" field's value of the Migrations entity.
// If the Migrations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MigrationsMutation) OldMigrated(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMigrated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMigrated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMigrated: %w", err)
	}
	return oldValue.Migrated, nil
}

// AddMigrated adds i to the "migrated" field.
func (m *MigrationsMutation) AddMigrated(i int) {
	if m.addmigrated != nil {
		*m.addmigrated += i
	} else {
		m.addmigrated = &i
	}
}

// AddedMigrated returns the value that was added to the "migrated" field in this mutation.
func (m *MigrationsMutation) AddedMigrated() (r int, exists bool) {
	v := m.addmigrated
	if v == nil {
		return
	}
	return *v, true
}

// ResetMigrated resets all changes to the "migrated" field.
func (m *MigrationsMutation) ResetMigrated() {
	m.migrated = nil
	m.addmigrated = nil
}

// Where appends a list predicates to the MigrationsMutation builder.
func (m *MigrationsMutation) Where(ps ...predicate.Migrations) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MigrationsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MigrationsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Migrations, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MigrationsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MigrationsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Migrations).
func (m *MigrationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MigrationsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.migrated != nil {
		fields = append(fields, migrations.FieldMigrated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MigrationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case migrations.FieldMigrated:
		return m.Migrated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MigrationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case migrations.FieldMigrated:
		return m.OldMigrated(ctx)
	}
	return nil, fmt.Errorf("unknown Migrations field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MigrationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case migrations.FieldMigrated:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMigrated(v)
		return nil
	}
	return fmt.Errorf("unknown Migrations field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MigrationsMutation) AddedFields() []string {
	var fields []string
	if m.addmigrated != nil {
		fields = append(fields, migrations.FieldMigrated)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MigrationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case migrations.FieldMigrated:
		return m.AddedMigrated()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MigrationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case migrations.FieldMigrated:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMigrated(v)
		return nil
	}
	return fmt.Errorf("unknown Migrations numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MigrationsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MigrationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MigrationsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Migrations nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MigrationsMutation) ResetField(name string) error {
	switch name {
	case migrations.FieldMigrated:
		m.ResetMigrated()
		return nil
	}
	return fmt.Errorf("unknown Migrations field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MigrationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MigrationsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MigrationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MigrationsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MigrationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MigrationsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MigrationsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Migrations unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MigrationsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Migrations edge %s", name)
}

// PartMutation represents an operation that mutates the Part nodes in the graph.
type PartMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	number          *int
	addnumber       *int
	title           *string
	annotation      *string
	clearedFields   map[string]struct{}
	chapters        map[string]struct{}
	removedchapters map[string]struct{}
	clearedchapters bool
	release         *string
	clearedrelease  bool
	done            bool
	oldValue        func(context.Context) (*Part, error)
	predicates      []predicate.Part
}

var _ ent.Mutation = (*PartMutation)(nil)

// partOption allows management of the mutation configuration using functional options.
type partOption func(*PartMutation)

// newPartMutation creates new mutation for the Part entity.
func newPartMutation(c config, op Op, opts ...partOption) *PartMutation {
	m := &PartMutation{
		config:        c,
		op:            op,
		typ:           TypePart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartID sets the ID field of the mutation.
func withPartID(id string) partOption {
	return func(m *PartMutation) {
		var (
			err   error
			once  sync.Once
			value *Part
		)
		m.oldValue = func(ctx context.Context) (*Part, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Part.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPart sets the old Part of the mutation.
func withPart(node *Part) partOption {
	return func(m *PartMutation) {
		m.oldValue = func(context.Context) (*Part, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Part entities.
func (m *PartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Part.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PartMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PartMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PartMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[part.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PartMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[part.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PartMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, part.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *PartMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *PartMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *PartMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *PartMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumber clears the value of the "number" field.
func (m *PartMutation) ClearNumber() {
	m.number = nil
	m.addnumber = nil
	m.clearedFields[part.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *PartMutation) NumberCleared() bool {
	_, ok := m.clearedFields[part.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *PartMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
	delete(m.clearedFields, part.FieldNumber)
}

// SetTitle sets the "title" field.
func (m *PartMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PartMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PartMutation) ResetTitle() {
	m.title = nil
}

// SetAnnotation sets the "annotation" field.
func (m *PartMutation) SetAnnotation(s string) {
	m.annotation = &s
}

// Annotation returns the value of the "annotation" field in the mutation.
func (m *PartMutation) Annotation() (r string, exists bool) {
	v := m.annotation
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotation returns the old "annotation" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldAnnotation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnotation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotation: %w", err)
	}
	return oldValue.Annotation, nil
}

// ClearAnnotation clears the value of the "annotation" field.
func (m *PartMutation) ClearAnnotation() {
	m.annotation = nil
	m.clearedFields[part.FieldAnnotation] = struct{}{}
}

// AnnotationCleared returns if the "annotation" field was cleared in this mutation.
func (m *PartMutation) AnnotationCleared() bool {
	_, ok := m.clearedFields[part.FieldAnnotation]
	return ok
}

// ResetAnnotation resets all changes to the "annotation" field.
func (m *PartMutation) ResetAnnotation() {
	m.annotation = nil
	delete(m.clearedFields, part.FieldAnnotation)
}

// SetReleaseUUID sets the "release_uuid" field.
func (m *PartMutation) SetReleaseUUID(s string) {
	m.release = &s
}

// ReleaseUUID returns the value of the "release_uuid" field in the mutation.
func (m *PartMutation) ReleaseUUID() (r string, exists bool) {
	v := m.release
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseUUID returns the old "release_uuid" field's value of the Part entity.
// If the Part object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartMutation) OldReleaseUUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseUUID: %w", err)
	}
	return oldValue.ReleaseUUID, nil
}

// ClearReleaseUUID clears the value of the "release_uuid" field.
func (m *PartMutation) ClearReleaseUUID() {
	m.release = nil
	m.clearedFields[part.FieldReleaseUUID] = struct{}{}
}

// ReleaseUUIDCleared returns if the "release_uuid" field was cleared in this mutation.
func (m *PartMutation) ReleaseUUIDCleared() bool {
	_, ok := m.clearedFields[part.FieldReleaseUUID]
	return ok
}

// ResetReleaseUUID resets all changes to the "release_uuid" field.
func (m *PartMutation) ResetReleaseUUID() {
	m.release = nil
	delete(m.clearedFields, part.FieldReleaseUUID)
}

// AddChapterIDs adds the "chapters" edge to the Chapter entity by ids.
func (m *PartMutation) AddChapterIDs(ids ...string) {
	if m.chapters == nil {
		m.chapters = make(map[string]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the Chapter entity.
func (m *PartMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the Chapter entity was cleared.
func (m *PartMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the Chapter entity by IDs.
func (m *PartMutation) RemoveChapterIDs(ids ...string) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the Chapter entity.
func (m *PartMutation) RemovedChaptersIDs() (ids []string) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *PartMutation) ChaptersIDs() (ids []string) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *PartMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// SetReleaseID sets the "release" edge to the Release entity by id.
func (m *PartMutation) SetReleaseID(id string) {
	m.release = &id
}

// ClearRelease clears the "release" edge to the Release entity.
func (m *PartMutation) ClearRelease() {
	m.clearedrelease = true
}

// ReleaseCleared reports if the "release" edge to the Release entity was cleared.
func (m *PartMutation) ReleaseCleared() bool {
	return m.ReleaseUUIDCleared() || m.clearedrelease
}

// ReleaseID returns the "release" edge ID in the mutation.
func (m *PartMutation) ReleaseID() (id string, exists bool) {
	if m.release != nil {
		return *m.release, true
	}
	return
}

// ReleaseIDs returns the "release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *PartMutation) ReleaseIDs() (ids []string) {
	if id := m.release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "release" edge.
func (m *PartMutation) ResetRelease() {
	m.release = nil
	m.clearedrelease = false
}

// Where appends a list predicates to the PartMutation builder.
func (m *PartMutation) Where(ps ...predicate.Part) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Part, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Part).
func (m *PartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, part.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, part.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, part.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, part.FieldNumber)
	}
	if m.title != nil {
		fields = append(fields, part.FieldTitle)
	}
	if m.annotation != nil {
		fields = append(fields, part.FieldAnnotation)
	}
	if m.release != nil {
		fields = append(fields, part.FieldReleaseUUID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case part.FieldCreatedAt:
		return m.CreatedAt()
	case part.FieldUpdatedAt:
		return m.UpdatedAt()
	case part.FieldDeletedAt:
		return m.DeletedAt()
	case part.FieldNumber:
		return m.Number()
	case part.FieldTitle:
		return m.Title()
	case part.FieldAnnotation:
		return m.Annotation()
	case part.FieldReleaseUUID:
		return m.ReleaseUUID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case part.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case part.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case part.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case part.FieldNumber:
		return m.OldNumber(ctx)
	case part.FieldTitle:
		return m.OldTitle(ctx)
	case part.FieldAnnotation:
		return m.OldAnnotation(ctx)
	case part.FieldReleaseUUID:
		return m.OldReleaseUUID(ctx)
	}
	return nil, fmt.Errorf("unknown Part field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case part.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case part.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case part.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case part.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case part.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case part.FieldAnnotation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotation(v)
		return nil
	case part.FieldReleaseUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseUUID(v)
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, part.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case part.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartMutation) AddField(name string, value ent.Value) error {
	switch name {
	case part.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Part numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(part.FieldDeletedAt) {
		fields = append(fields, part.FieldDeletedAt)
	}
	if m.FieldCleared(part.FieldNumber) {
		fields = append(fields, part.FieldNumber)
	}
	if m.FieldCleared(part.FieldAnnotation) {
		fields = append(fields, part.FieldAnnotation)
	}
	if m.FieldCleared(part.FieldReleaseUUID) {
		fields = append(fields, part.FieldReleaseUUID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartMutation) ClearField(name string) error {
	switch name {
	case part.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case part.FieldNumber:
		m.ClearNumber()
		return nil
	case part.FieldAnnotation:
		m.ClearAnnotation()
		return nil
	case part.FieldReleaseUUID:
		m.ClearReleaseUUID()
		return nil
	}
	return fmt.Errorf("unknown Part nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartMutation) ResetField(name string) error {
	switch name {
	case part.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case part.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case part.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case part.FieldNumber:
		m.ResetNumber()
		return nil
	case part.FieldTitle:
		m.ResetTitle()
		return nil
	case part.FieldAnnotation:
		m.ResetAnnotation()
		return nil
	case part.FieldReleaseUUID:
		m.ResetReleaseUUID()
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chapters != nil {
		edges = append(edges, part.EdgeChapters)
	}
	if m.release != nil {
		edges = append(edges, part.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case part.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case part.EdgeRelease:
		if id := m.release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchapters != nil {
		edges = append(edges, part.EdgeChapters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case part.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchapters {
		edges = append(edges, part.EdgeChapters)
	}
	if m.clearedrelease {
		edges = append(edges, part.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartMutation) EdgeCleared(name string) bool {
	switch name {
	case part.EdgeChapters:
		return m.clearedchapters
	case part.EdgeRelease:
		return m.clearedrelease
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartMutation) ClearEdge(name string) error {
	switch name {
	case part.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown Part unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartMutation) ResetEdge(name string) error {
	switch name {
	case part.EdgeChapters:
		m.ResetChapters()
		return nil
	case part.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown Part edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *permissions.Type
	description   *string
	clearedFields map[string]struct{}
	roles         map[roles.Type]struct{}
	removedroles  map[roles.Type]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id permissions.Type) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id permissions.Type) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id permissions.Type, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]permissions.Type, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []permissions.Type{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *PermissionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PermissionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PermissionMutation) ResetDescription() {
	m.description = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...roles.Type) {
	if m.roles == nil {
		m.roles = make(map[roles.Type]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...roles.Type) {
	if m.removedroles == nil {
		m.removedroles = make(map[roles.Type]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []roles.Type) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []roles.Type) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.description != nil {
		fields = append(fields, permission.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	release_date    *time.Time
	description     *string
	clearedFields   map[string]struct{}
	chapters        map[string]struct{}
	removedchapters map[string]struct{}
	clearedchapters bool
	parts           map[string]struct{}
	removedparts    map[string]struct{}
	clearedparts    bool
	done            bool
	oldValue        func(context.Context) (*Release, error)
	predicates      []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id string) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Release entities.
func (m *ReleaseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReleaseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Release.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReleaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReleaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReleaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReleaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReleaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReleaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *ReleaseMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *ReleaseMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *ReleaseMutation) ResetReleaseDate() {
	m.release_date = nil
}

// SetDescription sets the "description" field.
func (m *ReleaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReleaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ReleaseMutation) ResetDescription() {
	m.description = nil
}

// AddChapterIDs adds the "chapters" edge to the Chapter entity by ids.
func (m *ReleaseMutation) AddChapterIDs(ids ...string) {
	if m.chapters == nil {
		m.chapters = make(map[string]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the Chapter entity.
func (m *ReleaseMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the Chapter entity was cleared.
func (m *ReleaseMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the Chapter entity by IDs.
func (m *ReleaseMutation) RemoveChapterIDs(ids ...string) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the Chapter entity.
func (m *ReleaseMutation) RemovedChaptersIDs() (ids []string) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *ReleaseMutation) ChaptersIDs() (ids []string) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *ReleaseMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// AddPartIDs adds the "parts" edge to the Part entity by ids.
func (m *ReleaseMutation) AddPartIDs(ids ...string) {
	if m.parts == nil {
		m.parts = make(map[string]struct{})
	}
	for i := range ids {
		m.parts[ids[i]] = struct{}{}
	}
}

// ClearParts clears the "parts" edge to the Part entity.
func (m *ReleaseMutation) ClearParts() {
	m.clearedparts = true
}

// PartsCleared reports if the "parts" edge to the Part entity was cleared.
func (m *ReleaseMutation) PartsCleared() bool {
	return m.clearedparts
}

// RemovePartIDs removes the "parts" edge to the Part entity by IDs.
func (m *ReleaseMutation) RemovePartIDs(ids ...string) {
	if m.removedparts == nil {
		m.removedparts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.parts, ids[i])
		m.removedparts[ids[i]] = struct{}{}
	}
}

// RemovedParts returns the removed IDs of the "parts" edge to the Part entity.
func (m *ReleaseMutation) RemovedPartsIDs() (ids []string) {
	for id := range m.removedparts {
		ids = append(ids, id)
	}
	return
}

// PartsIDs returns the "parts" edge IDs in the mutation.
func (m *ReleaseMutation) PartsIDs() (ids []string) {
	for id := range m.parts {
		ids = append(ids, id)
	}
	return
}

// ResetParts resets all changes to the "parts" edge.
func (m *ReleaseMutation) ResetParts() {
	m.parts = nil
	m.clearedparts = false
	m.removedparts = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReleaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReleaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Release, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReleaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, release.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, release.FieldUpdatedAt)
	}
	if m.release_date != nil {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m.description != nil {
		fields = append(fields, release.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldCreatedAt:
		return m.CreatedAt()
	case release.FieldUpdatedAt:
		return m.UpdatedAt()
	case release.FieldReleaseDate:
		return m.ReleaseDate()
	case release.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case release.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case release.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case release.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case release.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case release.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case release.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case release.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case release.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case release.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chapters != nil {
		edges = append(edges, release.EdgeChapters)
	}
	if m.parts != nil {
		edges = append(edges, release.EdgeParts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeParts:
		ids := make([]ent.Value, 0, len(m.parts))
		for id := range m.parts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchapters != nil {
		edges = append(edges, release.EdgeChapters)
	}
	if m.removedparts != nil {
		edges = append(edges, release.EdgeParts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	case release.EdgeParts:
		ids := make([]ent.Value, 0, len(m.removedparts))
		for id := range m.removedparts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchapters {
		edges = append(edges, release.EdgeChapters)
	}
	if m.clearedparts {
		edges = append(edges, release.EdgeParts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeChapters:
		return m.clearedchapters
	case release.EdgeParts:
		return m.clearedparts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeChapters:
		m.ResetChapters()
		return nil
	case release.EdgeParts:
		m.ResetParts()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *roles.Type
	description        *string
	release_delay      *float64
	addrelease_delay   *float64
	clearedFields      map[string]struct{}
	users              map[string]struct{}
	removedusers       map[string]struct{}
	clearedusers       bool
	permissions        map[permissions.Type]struct{}
	removedpermissions map[permissions.Type]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id roles.Type) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id roles.Type) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id roles.Type, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]roles.Type, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []roles.Type{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
}

// SetReleaseDelay sets the "release_delay" field.
func (m *RoleMutation) SetReleaseDelay(f float64) {
	m.release_delay = &f
	m.addrelease_delay = nil
}

// ReleaseDelay returns the value of the "release_delay" field in the mutation.
func (m *RoleMutation) ReleaseDelay() (r float64, exists bool) {
	v := m.release_delay
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDelay returns the old "release_delay" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldReleaseDelay(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDelay: %w", err)
	}
	return oldValue.ReleaseDelay, nil
}

// AddReleaseDelay adds f to the "release_delay" field.
func (m *RoleMutation) AddReleaseDelay(f float64) {
	if m.addrelease_delay != nil {
		*m.addrelease_delay += f
	} else {
		m.addrelease_delay = &f
	}
}

// AddedReleaseDelay returns the value that was added to the "release_delay" field in this mutation.
func (m *RoleMutation) AddedReleaseDelay() (r float64, exists bool) {
	v := m.addrelease_delay
	if v == nil {
		return
	}
	return *v, true
}

// ResetReleaseDelay resets all changes to the "release_delay" field.
func (m *RoleMutation) ResetReleaseDelay() {
	m.release_delay = nil
	m.addrelease_delay = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...permissions.Type) {
	if m.permissions == nil {
		m.permissions = make(map[permissions.Type]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...permissions.Type) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[permissions.Type]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []permissions.Type) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []permissions.Type) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.release_delay != nil {
		fields = append(fields, role.FieldReleaseDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDescription:
		return m.Description()
	case role.FieldReleaseDelay:
		return m.ReleaseDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldReleaseDelay:
		return m.OldReleaseDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldReleaseDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addrelease_delay != nil {
		fields = append(fields, role.FieldReleaseDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldReleaseDelay:
		return m.AddedReleaseDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldReleaseDelay:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReleaseDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldReleaseDelay:
		m.ResetReleaseDelay()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SeedMigrationsMutation represents an operation that mutates the SeedMigrations nodes in the graph.
type SeedMigrationsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	migrated      *int
	addmigrated   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SeedMigrations, error)
	predicates    []predicate.SeedMigrations
}

var _ ent.Mutation = (*SeedMigrationsMutation)(nil)

// seedmigrationsOption allows management of the mutation configuration using functional options.
type seedmigrationsOption func(*SeedMigrationsMutation)

// newSeedMigrationsMutation creates new mutation for the SeedMigrations entity.
func newSeedMigrationsMutation(c config, op Op, opts ...seedmigrationsOption) *SeedMigrationsMutation {
	m := &SeedMigrationsMutation{
		config:        c,
		op:            op,
		typ:           TypeSeedMigrations,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeedMigrationsID sets the ID field of the mutation.
func withSeedMigrationsID(id int) seedmigrationsOption {
	return func(m *SeedMigrationsMutation) {
		var (
			err   error
			once  sync.Once
			value *SeedMigrations
		)
		m.oldValue = func(ctx context.Context) (*SeedMigrations, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeedMigrations.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeedMigrations sets the old SeedMigrations of the mutation.
func withSeedMigrations(node *SeedMigrations) seedmigrationsOption {
	return func(m *SeedMigrationsMutation) {
		m.oldValue = func(context.Context) (*SeedMigrations, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeedMigrationsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeedMigrationsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeedMigrationsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeedMigrationsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeedMigrations.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMigrated sets the "migrated" field.
func (m *SeedMigrationsMutation) SetMigrated(i int) {
	m.migrated = &i
	m.addmigrated = nil
}

// Migrated returns the value of the "migrated" field in the mutation.
func (m *SeedMigrationsMutation) Migrated() (r int, exists bool) {
	v := m.migrated
	if v == nil {
		return
	}
	return *v, true
}

// OldMigrated returns the old "migrated" field's value of the SeedMigrations entity.
// If the SeedMigrations object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeedMigrationsMutation) OldMigrated(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMigrated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMigrated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMigrated: %w", err)
	}
	return oldValue.Migrated, nil
}

// AddMigrated adds i to the "migrated" field.
func (m *SeedMigrationsMutation) AddMigrated(i int) {
	if m.addmigrated != nil {
		*m.addmigrated += i
	} else {
		m.addmigrated = &i
	}
}

// AddedMigrated returns the value that was added to the "migrated" field in this mutation.
func (m *SeedMigrationsMutation) AddedMigrated() (r int, exists bool) {
	v := m.addmigrated
	if v == nil {
		return
	}
	return *v, true
}

// ResetMigrated resets all changes to the "migrated" field.
func (m *SeedMigrationsMutation) ResetMigrated() {
	m.migrated = nil
	m.addmigrated = nil
}

// Where appends a list predicates to the SeedMigrationsMutation builder.
func (m *SeedMigrationsMutation) Where(ps ...predicate.SeedMigrations) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeedMigrationsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeedMigrationsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeedMigrations, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeedMigrationsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeedMigrationsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeedMigrations).
func (m *SeedMigrationsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeedMigrationsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.migrated != nil {
		fields = append(fields, seedmigrations.FieldMigrated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeedMigrationsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seedmigrations.FieldMigrated:
		return m.Migrated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeedMigrationsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seedmigrations.FieldMigrated:
		return m.OldMigrated(ctx)
	}
	return nil, fmt.Errorf("unknown SeedMigrations field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeedMigrationsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seedmigrations.FieldMigrated:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMigrated(v)
		return nil
	}
	return fmt.Errorf("unknown SeedMigrations field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeedMigrationsMutation) AddedFields() []string {
	var fields []string
	if m.addmigrated != nil {
		fields = append(fields, seedmigrations.FieldMigrated)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeedMigrationsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case seedmigrations.FieldMigrated:
		return m.AddedMigrated()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeedMigrationsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case seedmigrations.FieldMigrated:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMigrated(v)
		return nil
	}
	return fmt.Errorf("unknown SeedMigrations numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeedMigrationsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeedMigrationsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeedMigrationsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SeedMigrations nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeedMigrationsMutation) ResetField(name string) error {
	switch name {
	case seedmigrations.FieldMigrated:
		m.ResetMigrated()
		return nil
	}
	return fmt.Errorf("unknown SeedMigrations field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeedMigrationsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeedMigrationsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeedMigrationsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeedMigrationsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeedMigrationsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeedMigrationsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeedMigrationsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SeedMigrations unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeedMigrationsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SeedMigrations edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	email            *string
	fullname         *string
	username         *string
	password_hash    *string
	vk_id            *int64
	addvk_id         *int64
	score            *int
	addscore         *int
	email_verified   *bool
	serial_number    *uint
	addserial_number *int
	clearedFields    map[string]struct{}
	roles            map[roles.Type]struct{}
	removedroles     map[roles.Type]struct{}
	clearedroles     bool
	files            map[string]struct{}
	removedfiles     map[string]struct{}
	clearedfiles     bool
	comments         map[string]struct{}
	removedcomments  map[string]struct{}
	clearedcomments  bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetFullname sets the "fullname" field.
func (m *UserMutation) SetFullname(s string) {
	m.fullname = &s
}

// Fullname returns the value of the "fullname" field in the mutation.
func (m *UserMutation) Fullname() (r string, exists bool) {
	v := m.fullname
	if v == nil {
		return
	}
	return *v, true
}

// OldFullname returns the old "fullname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullname: %w", err)
	}
	return oldValue.Fullname, nil
}

// ResetFullname resets all changes to the "fullname" field.
func (m *UserMutation) ResetFullname() {
	m.fullname = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetVkID sets the "vk_id" field.
func (m *UserMutation) SetVkID(i int64) {
	m.vk_id = &i
	m.addvk_id = nil
}

// VkID returns the value of the "vk_id" field in the mutation.
func (m *UserMutation) VkID() (r int64, exists bool) {
	v := m.vk_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVkID returns the old "vk_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVkID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVkID: %w", err)
	}
	return oldValue.VkID, nil
}

// AddVkID adds i to the "vk_id" field.
func (m *UserMutation) AddVkID(i int64) {
	if m.addvk_id != nil {
		*m.addvk_id += i
	} else {
		m.addvk_id = &i
	}
}

// AddedVkID returns the value that was added to the "vk_id" field in this mutation.
func (m *UserMutation) AddedVkID() (r int64, exists bool) {
	v := m.addvk_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVkID clears the value of the "vk_id" field.
func (m *UserMutation) ClearVkID() {
	m.vk_id = nil
	m.addvk_id = nil
	m.clearedFields[user.FieldVkID] = struct{}{}
}

// VkIDCleared returns if the "vk_id" field was cleared in this mutation.
func (m *UserMutation) VkIDCleared() bool {
	_, ok := m.clearedFields[user.FieldVkID]
	return ok
}

// ResetVkID resets all changes to the "vk_id" field.
func (m *UserMutation) ResetVkID() {
	m.vk_id = nil
	m.addvk_id = nil
	delete(m.clearedFields, user.FieldVkID)
}

// SetScore sets the "score" field.
func (m *UserMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *UserMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *UserMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *UserMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *UserMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetSerialNumber sets the "serial_number" field.
func (m *UserMutation) SetSerialNumber(u uint) {
	m.serial_number = &u
	m.addserial_number = nil
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *UserMutation) SerialNumber() (r uint, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSerialNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// AddSerialNumber adds u to the "serial_number" field.
func (m *UserMutation) AddSerialNumber(u int) {
	if m.addserial_number != nil {
		*m.addserial_number += u
	} else {
		m.addserial_number = &u
	}
}

// AddedSerialNumber returns the value that was added to the "serial_number" field in this mutation.
func (m *UserMutation) AddedSerialNumber() (r int, exists bool) {
	v := m.addserial_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *UserMutation) ResetSerialNumber() {
	m.serial_number = nil
	m.addserial_number = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...roles.Type) {
	if m.roles == nil {
		m.roles = make(map[roles.Type]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...roles.Type) {
	if m.removedroles == nil {
		m.removedroles = make(map[roles.Type]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []roles.Type) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []roles.Type) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...string) {
	if m.files == nil {
		m.files = make(map[string]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *UserMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *UserMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...string) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *UserMutation) RemovedFilesIDs() (ids []string) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *UserMutation) FilesIDs() (ids []string) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *UserMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...string) {
	if m.comments == nil {
		m.comments = make(map[string]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...string) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []string) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []string) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.fullname != nil {
		fields = append(fields, user.FieldFullname)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.vk_id != nil {
		fields = append(fields, user.FieldVkID)
	}
	if m.score != nil {
		fields = append(fields, user.FieldScore)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.serial_number != nil {
		fields = append(fields, user.FieldSerialNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFullname:
		return m.Fullname()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldVkID:
		return m.VkID()
	case user.FieldScore:
		return m.Score()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldSerialNumber:
		return m.SerialNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFullname:
		return m.OldFullname(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldVkID:
		return m.OldVkID(ctx)
	case user.FieldScore:
		return m.OldScore(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFullname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullname(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldVkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVkID(v)
		return nil
	case user.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldSerialNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addvk_id != nil {
		fields = append(fields, user.FieldVkID)
	}
	if m.addscore != nil {
		fields = append(fields, user.FieldScore)
	}
	if m.addserial_number != nil {
		fields = append(fields, user.FieldSerialNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldVkID:
		return m.AddedVkID()
	case user.FieldScore:
		return m.AddedScore()
	case user.FieldSerialNumber:
		return m.AddedSerialNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldVkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVkID(v)
		return nil
	case user.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case user.FieldSerialNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSerialNumber(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldVkID) {
		fields = append(fields, user.FieldVkID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldVkID:
		m.ClearVkID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFullname:
		m.ResetFullname()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldVkID:
		m.ResetVkID()
		return nil
	case user.FieldScore:
		m.ResetScore()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.files != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedfiles != nil {
		edges = append(edges, user.EdgeFiles)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedfiles {
		edges = append(edges, user.EdgeFiles)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeFiles:
		return m.clearedfiles
	case user.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeFiles:
		m.ResetFiles()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
