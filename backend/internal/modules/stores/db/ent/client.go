// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"waterfall-backend/internal/models/permissions"
	"waterfall-backend/internal/models/roles"
	"waterfall-backend/internal/modules/stores/db/ent/migrate"

	"waterfall-backend/internal/modules/stores/db/ent/chapter"
	"waterfall-backend/internal/modules/stores/db/ent/chaptertext"
	"waterfall-backend/internal/modules/stores/db/ent/comment"
	"waterfall-backend/internal/modules/stores/db/ent/file"
	"waterfall-backend/internal/modules/stores/db/ent/migrations"
	"waterfall-backend/internal/modules/stores/db/ent/part"
	"waterfall-backend/internal/modules/stores/db/ent/permission"
	"waterfall-backend/internal/modules/stores/db/ent/release"
	"waterfall-backend/internal/modules/stores/db/ent/role"
	"waterfall-backend/internal/modules/stores/db/ent/seedmigrations"
	"waterfall-backend/internal/modules/stores/db/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Chapter is the client for interacting with the Chapter builders.
	Chapter *ChapterClient
	// ChapterText is the client for interacting with the ChapterText builders.
	ChapterText *ChapterTextClient
	// Comment is the client for interacting with the Comment builders.
	Comment *CommentClient
	// File is the client for interacting with the File builders.
	File *FileClient
	// Migrations is the client for interacting with the Migrations builders.
	Migrations *MigrationsClient
	// Part is the client for interacting with the Part builders.
	Part *PartClient
	// Permission is the client for interacting with the Permission builders.
	Permission *PermissionClient
	// Release is the client for interacting with the Release builders.
	Release *ReleaseClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// SeedMigrations is the client for interacting with the SeedMigrations builders.
	SeedMigrations *SeedMigrationsClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Chapter = NewChapterClient(c.config)
	c.ChapterText = NewChapterTextClient(c.config)
	c.Comment = NewCommentClient(c.config)
	c.File = NewFileClient(c.config)
	c.Migrations = NewMigrationsClient(c.config)
	c.Part = NewPartClient(c.config)
	c.Permission = NewPermissionClient(c.config)
	c.Release = NewReleaseClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.SeedMigrations = NewSeedMigrationsClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Chapter:        NewChapterClient(cfg),
		ChapterText:    NewChapterTextClient(cfg),
		Comment:        NewCommentClient(cfg),
		File:           NewFileClient(cfg),
		Migrations:     NewMigrationsClient(cfg),
		Part:           NewPartClient(cfg),
		Permission:     NewPermissionClient(cfg),
		Release:        NewReleaseClient(cfg),
		Role:           NewRoleClient(cfg),
		SeedMigrations: NewSeedMigrationsClient(cfg),
		User:           NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		Chapter:        NewChapterClient(cfg),
		ChapterText:    NewChapterTextClient(cfg),
		Comment:        NewCommentClient(cfg),
		File:           NewFileClient(cfg),
		Migrations:     NewMigrationsClient(cfg),
		Part:           NewPartClient(cfg),
		Permission:     NewPermissionClient(cfg),
		Release:        NewReleaseClient(cfg),
		Role:           NewRoleClient(cfg),
		SeedMigrations: NewSeedMigrationsClient(cfg),
		User:           NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Chapter.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Chapter, c.ChapterText, c.Comment, c.File, c.Migrations, c.Part, c.Permission,
		c.Release, c.Role, c.SeedMigrations, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Chapter, c.ChapterText, c.Comment, c.File, c.Migrations, c.Part, c.Permission,
		c.Release, c.Role, c.SeedMigrations, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ChapterMutation:
		return c.Chapter.mutate(ctx, m)
	case *ChapterTextMutation:
		return c.ChapterText.mutate(ctx, m)
	case *CommentMutation:
		return c.Comment.mutate(ctx, m)
	case *FileMutation:
		return c.File.mutate(ctx, m)
	case *MigrationsMutation:
		return c.Migrations.mutate(ctx, m)
	case *PartMutation:
		return c.Part.mutate(ctx, m)
	case *PermissionMutation:
		return c.Permission.mutate(ctx, m)
	case *ReleaseMutation:
		return c.Release.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *SeedMigrationsMutation:
		return c.SeedMigrations.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ChapterClient is a client for the Chapter schema.
type ChapterClient struct {
	config
}

// NewChapterClient returns a client for the Chapter from the given config.
func NewChapterClient(c config) *ChapterClient {
	return &ChapterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chapter.Hooks(f(g(h())))`.
func (c *ChapterClient) Use(hooks ...Hook) {
	c.hooks.Chapter = append(c.hooks.Chapter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chapter.Intercept(f(g(h())))`.
func (c *ChapterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Chapter = append(c.inters.Chapter, interceptors...)
}

// Create returns a builder for creating a Chapter entity.
func (c *ChapterClient) Create() *ChapterCreate {
	mutation := newChapterMutation(c.config, OpCreate)
	return &ChapterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chapter entities.
func (c *ChapterClient) CreateBulk(builders ...*ChapterCreate) *ChapterCreateBulk {
	return &ChapterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chapter.
func (c *ChapterClient) Update() *ChapterUpdate {
	mutation := newChapterMutation(c.config, OpUpdate)
	return &ChapterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChapterClient) UpdateOne(ch *Chapter) *ChapterUpdateOne {
	mutation := newChapterMutation(c.config, OpUpdateOne, withChapter(ch))
	return &ChapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChapterClient) UpdateOneID(id string) *ChapterUpdateOne {
	mutation := newChapterMutation(c.config, OpUpdateOne, withChapterID(id))
	return &ChapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chapter.
func (c *ChapterClient) Delete() *ChapterDelete {
	mutation := newChapterMutation(c.config, OpDelete)
	return &ChapterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChapterClient) DeleteOne(ch *Chapter) *ChapterDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChapterClient) DeleteOneID(id string) *ChapterDeleteOne {
	builder := c.Delete().Where(chapter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChapterDeleteOne{builder}
}

// Query returns a query builder for Chapter.
func (c *ChapterClient) Query() *ChapterQuery {
	return &ChapterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChapter},
		inters: c.Interceptors(),
	}
}

// Get returns a Chapter entity by its id.
func (c *ChapterClient) Get(ctx context.Context, id string) (*Chapter, error) {
	return c.Query().Where(chapter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChapterClient) GetX(ctx context.Context, id string) *Chapter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPart queries the part edge of a Chapter.
func (c *ChapterClient) QueryPart(ch *Chapter) *PartQuery {
	query := (&PartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chapter.Table, chapter.FieldID, id),
			sqlgraph.To(part.Table, part.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chapter.PartTable, chapter.PartColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a Chapter.
func (c *ChapterClient) QueryRelease(ch *Chapter) *ReleaseQuery {
	query := (&ReleaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chapter.Table, chapter.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, chapter.ReleaseTable, chapter.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a Chapter.
func (c *ChapterClient) QueryComments(ch *Chapter) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chapter.Table, chapter.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, chapter.CommentsTable, chapter.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChapterText queries the chapter_text edge of a Chapter.
func (c *ChapterClient) QueryChapterText(ch *Chapter) *ChapterTextQuery {
	query := (&ChapterTextClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chapter.Table, chapter.FieldID, id),
			sqlgraph.To(chaptertext.Table, chaptertext.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, chapter.ChapterTextTable, chapter.ChapterTextColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChapterClient) Hooks() []Hook {
	hooks := c.hooks.Chapter
	return append(hooks[:len(hooks):len(hooks)], chapter.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ChapterClient) Interceptors() []Interceptor {
	inters := c.inters.Chapter
	return append(inters[:len(inters):len(inters)], chapter.Interceptors[:]...)
}

func (c *ChapterClient) mutate(ctx context.Context, m *ChapterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChapterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChapterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChapterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChapterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Chapter mutation op: %q", m.Op())
	}
}

// ChapterTextClient is a client for the ChapterText schema.
type ChapterTextClient struct {
	config
}

// NewChapterTextClient returns a client for the ChapterText from the given config.
func NewChapterTextClient(c config) *ChapterTextClient {
	return &ChapterTextClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chaptertext.Hooks(f(g(h())))`.
func (c *ChapterTextClient) Use(hooks ...Hook) {
	c.hooks.ChapterText = append(c.hooks.ChapterText, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chaptertext.Intercept(f(g(h())))`.
func (c *ChapterTextClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChapterText = append(c.inters.ChapterText, interceptors...)
}

// Create returns a builder for creating a ChapterText entity.
func (c *ChapterTextClient) Create() *ChapterTextCreate {
	mutation := newChapterTextMutation(c.config, OpCreate)
	return &ChapterTextCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChapterText entities.
func (c *ChapterTextClient) CreateBulk(builders ...*ChapterTextCreate) *ChapterTextCreateBulk {
	return &ChapterTextCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChapterText.
func (c *ChapterTextClient) Update() *ChapterTextUpdate {
	mutation := newChapterTextMutation(c.config, OpUpdate)
	return &ChapterTextUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChapterTextClient) UpdateOne(ct *ChapterText) *ChapterTextUpdateOne {
	mutation := newChapterTextMutation(c.config, OpUpdateOne, withChapterText(ct))
	return &ChapterTextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChapterTextClient) UpdateOneID(id string) *ChapterTextUpdateOne {
	mutation := newChapterTextMutation(c.config, OpUpdateOne, withChapterTextID(id))
	return &ChapterTextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChapterText.
func (c *ChapterTextClient) Delete() *ChapterTextDelete {
	mutation := newChapterTextMutation(c.config, OpDelete)
	return &ChapterTextDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChapterTextClient) DeleteOne(ct *ChapterText) *ChapterTextDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChapterTextClient) DeleteOneID(id string) *ChapterTextDeleteOne {
	builder := c.Delete().Where(chaptertext.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChapterTextDeleteOne{builder}
}

// Query returns a query builder for ChapterText.
func (c *ChapterTextClient) Query() *ChapterTextQuery {
	return &ChapterTextQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChapterText},
		inters: c.Interceptors(),
	}
}

// Get returns a ChapterText entity by its id.
func (c *ChapterTextClient) Get(ctx context.Context, id string) (*ChapterText, error) {
	return c.Query().Where(chaptertext.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChapterTextClient) GetX(ctx context.Context, id string) *ChapterText {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChapter queries the chapter edge of a ChapterText.
func (c *ChapterTextClient) QueryChapter(ct *ChapterText) *ChapterQuery {
	query := (&ChapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ct.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chaptertext.Table, chaptertext.FieldID, id),
			sqlgraph.To(chapter.Table, chapter.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, chaptertext.ChapterTable, chaptertext.ChapterColumn),
		)
		fromV = sqlgraph.Neighbors(ct.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChapterTextClient) Hooks() []Hook {
	hooks := c.hooks.ChapterText
	return append(hooks[:len(hooks):len(hooks)], chaptertext.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ChapterTextClient) Interceptors() []Interceptor {
	inters := c.inters.ChapterText
	return append(inters[:len(inters):len(inters)], chaptertext.Interceptors[:]...)
}

func (c *ChapterTextClient) mutate(ctx context.Context, m *ChapterTextMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChapterTextCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChapterTextUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChapterTextUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChapterTextDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChapterText mutation op: %q", m.Op())
	}
}

// CommentClient is a client for the Comment schema.
type CommentClient struct {
	config
}

// NewCommentClient returns a client for the Comment from the given config.
func NewCommentClient(c config) *CommentClient {
	return &CommentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `comment.Hooks(f(g(h())))`.
func (c *CommentClient) Use(hooks ...Hook) {
	c.hooks.Comment = append(c.hooks.Comment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `comment.Intercept(f(g(h())))`.
func (c *CommentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Comment = append(c.inters.Comment, interceptors...)
}

// Create returns a builder for creating a Comment entity.
func (c *CommentClient) Create() *CommentCreate {
	mutation := newCommentMutation(c.config, OpCreate)
	return &CommentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Comment entities.
func (c *CommentClient) CreateBulk(builders ...*CommentCreate) *CommentCreateBulk {
	return &CommentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Comment.
func (c *CommentClient) Update() *CommentUpdate {
	mutation := newCommentMutation(c.config, OpUpdate)
	return &CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommentClient) UpdateOne(co *Comment) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withComment(co))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommentClient) UpdateOneID(id string) *CommentUpdateOne {
	mutation := newCommentMutation(c.config, OpUpdateOne, withCommentID(id))
	return &CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Comment.
func (c *CommentClient) Delete() *CommentDelete {
	mutation := newCommentMutation(c.config, OpDelete)
	return &CommentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommentClient) DeleteOne(co *Comment) *CommentDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommentClient) DeleteOneID(id string) *CommentDeleteOne {
	builder := c.Delete().Where(comment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommentDeleteOne{builder}
}

// Query returns a query builder for Comment.
func (c *CommentClient) Query() *CommentQuery {
	return &CommentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComment},
		inters: c.Interceptors(),
	}
}

// Get returns a Comment entity by its id.
func (c *CommentClient) Get(ctx context.Context, id string) (*Comment, error) {
	return c.Query().Where(comment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommentClient) GetX(ctx context.Context, id string) *Comment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a Comment.
func (c *CommentClient) QueryAuthor(co *Comment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.AuthorTable, comment.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Comment.
func (c *CommentClient) QueryParent(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ParentTable, comment.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Comment.
func (c *CommentClient) QueryChildren(co *Comment) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, comment.ChildrenTable, comment.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChapter queries the chapter edge of a Comment.
func (c *CommentClient) QueryChapter(co *Comment) *ChapterQuery {
	query := (&ChapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(comment.Table, comment.FieldID, id),
			sqlgraph.To(chapter.Table, chapter.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, comment.ChapterTable, comment.ChapterColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommentClient) Hooks() []Hook {
	hooks := c.hooks.Comment
	return append(hooks[:len(hooks):len(hooks)], comment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *CommentClient) Interceptors() []Interceptor {
	inters := c.inters.Comment
	return append(inters[:len(inters):len(inters)], comment.Interceptors[:]...)
}

func (c *CommentClient) mutate(ctx context.Context, m *CommentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Comment mutation op: %q", m.Op())
	}
}

// FileClient is a client for the File schema.
type FileClient struct {
	config
}

// NewFileClient returns a client for the File from the given config.
func NewFileClient(c config) *FileClient {
	return &FileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `file.Hooks(f(g(h())))`.
func (c *FileClient) Use(hooks ...Hook) {
	c.hooks.File = append(c.hooks.File, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `file.Intercept(f(g(h())))`.
func (c *FileClient) Intercept(interceptors ...Interceptor) {
	c.inters.File = append(c.inters.File, interceptors...)
}

// Create returns a builder for creating a File entity.
func (c *FileClient) Create() *FileCreate {
	mutation := newFileMutation(c.config, OpCreate)
	return &FileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of File entities.
func (c *FileClient) CreateBulk(builders ...*FileCreate) *FileCreateBulk {
	return &FileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for File.
func (c *FileClient) Update() *FileUpdate {
	mutation := newFileMutation(c.config, OpUpdate)
	return &FileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileClient) UpdateOne(f *File) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFile(f))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileClient) UpdateOneID(id string) *FileUpdateOne {
	mutation := newFileMutation(c.config, OpUpdateOne, withFileID(id))
	return &FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for File.
func (c *FileClient) Delete() *FileDelete {
	mutation := newFileMutation(c.config, OpDelete)
	return &FileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileClient) DeleteOne(f *File) *FileDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileClient) DeleteOneID(id string) *FileDeleteOne {
	builder := c.Delete().Where(file.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteOne{builder}
}

// Query returns a query builder for File.
func (c *FileClient) Query() *FileQuery {
	return &FileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFile},
		inters: c.Interceptors(),
	}
}

// Get returns a File entity by its id.
func (c *FileClient) Get(ctx context.Context, id string) (*File, error) {
	return c.Query().Where(file.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileClient) GetX(ctx context.Context, id string) *File {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreator queries the creator edge of a File.
func (c *FileClient) QueryCreator(f *File) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(file.Table, file.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, file.CreatorTable, file.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileClient) Hooks() []Hook {
	hooks := c.hooks.File
	return append(hooks[:len(hooks):len(hooks)], file.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *FileClient) Interceptors() []Interceptor {
	return c.inters.File
}

func (c *FileClient) mutate(ctx context.Context, m *FileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown File mutation op: %q", m.Op())
	}
}

// MigrationsClient is a client for the Migrations schema.
type MigrationsClient struct {
	config
}

// NewMigrationsClient returns a client for the Migrations from the given config.
func NewMigrationsClient(c config) *MigrationsClient {
	return &MigrationsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `migrations.Hooks(f(g(h())))`.
func (c *MigrationsClient) Use(hooks ...Hook) {
	c.hooks.Migrations = append(c.hooks.Migrations, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `migrations.Intercept(f(g(h())))`.
func (c *MigrationsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Migrations = append(c.inters.Migrations, interceptors...)
}

// Create returns a builder for creating a Migrations entity.
func (c *MigrationsClient) Create() *MigrationsCreate {
	mutation := newMigrationsMutation(c.config, OpCreate)
	return &MigrationsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Migrations entities.
func (c *MigrationsClient) CreateBulk(builders ...*MigrationsCreate) *MigrationsCreateBulk {
	return &MigrationsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Migrations.
func (c *MigrationsClient) Update() *MigrationsUpdate {
	mutation := newMigrationsMutation(c.config, OpUpdate)
	return &MigrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MigrationsClient) UpdateOne(m *Migrations) *MigrationsUpdateOne {
	mutation := newMigrationsMutation(c.config, OpUpdateOne, withMigrations(m))
	return &MigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MigrationsClient) UpdateOneID(id int) *MigrationsUpdateOne {
	mutation := newMigrationsMutation(c.config, OpUpdateOne, withMigrationsID(id))
	return &MigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Migrations.
func (c *MigrationsClient) Delete() *MigrationsDelete {
	mutation := newMigrationsMutation(c.config, OpDelete)
	return &MigrationsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MigrationsClient) DeleteOne(m *Migrations) *MigrationsDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MigrationsClient) DeleteOneID(id int) *MigrationsDeleteOne {
	builder := c.Delete().Where(migrations.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MigrationsDeleteOne{builder}
}

// Query returns a query builder for Migrations.
func (c *MigrationsClient) Query() *MigrationsQuery {
	return &MigrationsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMigrations},
		inters: c.Interceptors(),
	}
}

// Get returns a Migrations entity by its id.
func (c *MigrationsClient) Get(ctx context.Context, id int) (*Migrations, error) {
	return c.Query().Where(migrations.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MigrationsClient) GetX(ctx context.Context, id int) *Migrations {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MigrationsClient) Hooks() []Hook {
	hooks := c.hooks.Migrations
	return append(hooks[:len(hooks):len(hooks)], migrations.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MigrationsClient) Interceptors() []Interceptor {
	return c.inters.Migrations
}

func (c *MigrationsClient) mutate(ctx context.Context, m *MigrationsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MigrationsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MigrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MigrationsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Migrations mutation op: %q", m.Op())
	}
}

// PartClient is a client for the Part schema.
type PartClient struct {
	config
}

// NewPartClient returns a client for the Part from the given config.
func NewPartClient(c config) *PartClient {
	return &PartClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `part.Hooks(f(g(h())))`.
func (c *PartClient) Use(hooks ...Hook) {
	c.hooks.Part = append(c.hooks.Part, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `part.Intercept(f(g(h())))`.
func (c *PartClient) Intercept(interceptors ...Interceptor) {
	c.inters.Part = append(c.inters.Part, interceptors...)
}

// Create returns a builder for creating a Part entity.
func (c *PartClient) Create() *PartCreate {
	mutation := newPartMutation(c.config, OpCreate)
	return &PartCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Part entities.
func (c *PartClient) CreateBulk(builders ...*PartCreate) *PartCreateBulk {
	return &PartCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Part.
func (c *PartClient) Update() *PartUpdate {
	mutation := newPartMutation(c.config, OpUpdate)
	return &PartUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PartClient) UpdateOne(pa *Part) *PartUpdateOne {
	mutation := newPartMutation(c.config, OpUpdateOne, withPart(pa))
	return &PartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PartClient) UpdateOneID(id string) *PartUpdateOne {
	mutation := newPartMutation(c.config, OpUpdateOne, withPartID(id))
	return &PartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Part.
func (c *PartClient) Delete() *PartDelete {
	mutation := newPartMutation(c.config, OpDelete)
	return &PartDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PartClient) DeleteOne(pa *Part) *PartDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PartClient) DeleteOneID(id string) *PartDeleteOne {
	builder := c.Delete().Where(part.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PartDeleteOne{builder}
}

// Query returns a query builder for Part.
func (c *PartClient) Query() *PartQuery {
	return &PartQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePart},
		inters: c.Interceptors(),
	}
}

// Get returns a Part entity by its id.
func (c *PartClient) Get(ctx context.Context, id string) (*Part, error) {
	return c.Query().Where(part.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PartClient) GetX(ctx context.Context, id string) *Part {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChapters queries the chapters edge of a Part.
func (c *PartClient) QueryChapters(pa *Part) *ChapterQuery {
	query := (&ChapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(part.Table, part.FieldID, id),
			sqlgraph.To(chapter.Table, chapter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, part.ChaptersTable, part.ChaptersColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRelease queries the release edge of a Part.
func (c *PartClient) QueryRelease(pa *Part) *ReleaseQuery {
	query := (&ReleaseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(part.Table, part.FieldID, id),
			sqlgraph.To(release.Table, release.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, part.ReleaseTable, part.ReleaseColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PartClient) Hooks() []Hook {
	hooks := c.hooks.Part
	return append(hooks[:len(hooks):len(hooks)], part.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PartClient) Interceptors() []Interceptor {
	inters := c.inters.Part
	return append(inters[:len(inters):len(inters)], part.Interceptors[:]...)
}

func (c *PartClient) mutate(ctx context.Context, m *PartMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PartCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PartUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PartDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Part mutation op: %q", m.Op())
	}
}

// PermissionClient is a client for the Permission schema.
type PermissionClient struct {
	config
}

// NewPermissionClient returns a client for the Permission from the given config.
func NewPermissionClient(c config) *PermissionClient {
	return &PermissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `permission.Hooks(f(g(h())))`.
func (c *PermissionClient) Use(hooks ...Hook) {
	c.hooks.Permission = append(c.hooks.Permission, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `permission.Intercept(f(g(h())))`.
func (c *PermissionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Permission = append(c.inters.Permission, interceptors...)
}

// Create returns a builder for creating a Permission entity.
func (c *PermissionClient) Create() *PermissionCreate {
	mutation := newPermissionMutation(c.config, OpCreate)
	return &PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Permission entities.
func (c *PermissionClient) CreateBulk(builders ...*PermissionCreate) *PermissionCreateBulk {
	return &PermissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Permission.
func (c *PermissionClient) Update() *PermissionUpdate {
	mutation := newPermissionMutation(c.config, OpUpdate)
	return &PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PermissionClient) UpdateOne(pe *Permission) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermission(pe))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PermissionClient) UpdateOneID(id permissions.Type) *PermissionUpdateOne {
	mutation := newPermissionMutation(c.config, OpUpdateOne, withPermissionID(id))
	return &PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Permission.
func (c *PermissionClient) Delete() *PermissionDelete {
	mutation := newPermissionMutation(c.config, OpDelete)
	return &PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PermissionClient) DeleteOne(pe *Permission) *PermissionDeleteOne {
	return c.DeleteOneID(pe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PermissionClient) DeleteOneID(id permissions.Type) *PermissionDeleteOne {
	builder := c.Delete().Where(permission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PermissionDeleteOne{builder}
}

// Query returns a query builder for Permission.
func (c *PermissionClient) Query() *PermissionQuery {
	return &PermissionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePermission},
		inters: c.Interceptors(),
	}
}

// Get returns a Permission entity by its id.
func (c *PermissionClient) Get(ctx context.Context, id permissions.Type) (*Permission, error) {
	return c.Query().Where(permission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PermissionClient) GetX(ctx context.Context, id permissions.Type) *Permission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Permission.
func (c *PermissionClient) QueryRoles(pe *Permission) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(permission.Table, permission.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, permission.RolesTable, permission.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PermissionClient) Hooks() []Hook {
	hooks := c.hooks.Permission
	return append(hooks[:len(hooks):len(hooks)], permission.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PermissionClient) Interceptors() []Interceptor {
	return c.inters.Permission
}

func (c *PermissionClient) mutate(ctx context.Context, m *PermissionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PermissionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PermissionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PermissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PermissionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Permission mutation op: %q", m.Op())
	}
}

// ReleaseClient is a client for the Release schema.
type ReleaseClient struct {
	config
}

// NewReleaseClient returns a client for the Release from the given config.
func NewReleaseClient(c config) *ReleaseClient {
	return &ReleaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `release.Hooks(f(g(h())))`.
func (c *ReleaseClient) Use(hooks ...Hook) {
	c.hooks.Release = append(c.hooks.Release, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `release.Intercept(f(g(h())))`.
func (c *ReleaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Release = append(c.inters.Release, interceptors...)
}

// Create returns a builder for creating a Release entity.
func (c *ReleaseClient) Create() *ReleaseCreate {
	mutation := newReleaseMutation(c.config, OpCreate)
	return &ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Release entities.
func (c *ReleaseClient) CreateBulk(builders ...*ReleaseCreate) *ReleaseCreateBulk {
	return &ReleaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Release.
func (c *ReleaseClient) Update() *ReleaseUpdate {
	mutation := newReleaseMutation(c.config, OpUpdate)
	return &ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReleaseClient) UpdateOne(r *Release) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withRelease(r))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReleaseClient) UpdateOneID(id string) *ReleaseUpdateOne {
	mutation := newReleaseMutation(c.config, OpUpdateOne, withReleaseID(id))
	return &ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Release.
func (c *ReleaseClient) Delete() *ReleaseDelete {
	mutation := newReleaseMutation(c.config, OpDelete)
	return &ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReleaseClient) DeleteOne(r *Release) *ReleaseDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReleaseClient) DeleteOneID(id string) *ReleaseDeleteOne {
	builder := c.Delete().Where(release.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReleaseDeleteOne{builder}
}

// Query returns a query builder for Release.
func (c *ReleaseClient) Query() *ReleaseQuery {
	return &ReleaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRelease},
		inters: c.Interceptors(),
	}
}

// Get returns a Release entity by its id.
func (c *ReleaseClient) Get(ctx context.Context, id string) (*Release, error) {
	return c.Query().Where(release.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReleaseClient) GetX(ctx context.Context, id string) *Release {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChapters queries the chapters edge of a Release.
func (c *ReleaseClient) QueryChapters(r *Release) *ChapterQuery {
	query := (&ChapterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(chapter.Table, chapter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, release.ChaptersTable, release.ChaptersColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParts queries the parts edge of a Release.
func (c *ReleaseClient) QueryParts(r *Release) *PartQuery {
	query := (&PartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(release.Table, release.FieldID, id),
			sqlgraph.To(part.Table, part.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, release.PartsTable, release.PartsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReleaseClient) Hooks() []Hook {
	hooks := c.hooks.Release
	return append(hooks[:len(hooks):len(hooks)], release.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ReleaseClient) Interceptors() []Interceptor {
	return c.inters.Release
}

func (c *ReleaseClient) mutate(ctx context.Context, m *ReleaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReleaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReleaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReleaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReleaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Release mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id roles.Type) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id roles.Type) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id roles.Type) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id roles.Type) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(r *Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, role.UsersTable, role.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPermissions queries the permissions edge of a Role.
func (c *RoleClient) QueryPermissions(r *Role) *PermissionQuery {
	query := (&PermissionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(permission.Table, permission.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, role.PermissionsTable, role.PermissionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// SeedMigrationsClient is a client for the SeedMigrations schema.
type SeedMigrationsClient struct {
	config
}

// NewSeedMigrationsClient returns a client for the SeedMigrations from the given config.
func NewSeedMigrationsClient(c config) *SeedMigrationsClient {
	return &SeedMigrationsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seedmigrations.Hooks(f(g(h())))`.
func (c *SeedMigrationsClient) Use(hooks ...Hook) {
	c.hooks.SeedMigrations = append(c.hooks.SeedMigrations, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `seedmigrations.Intercept(f(g(h())))`.
func (c *SeedMigrationsClient) Intercept(interceptors ...Interceptor) {
	c.inters.SeedMigrations = append(c.inters.SeedMigrations, interceptors...)
}

// Create returns a builder for creating a SeedMigrations entity.
func (c *SeedMigrationsClient) Create() *SeedMigrationsCreate {
	mutation := newSeedMigrationsMutation(c.config, OpCreate)
	return &SeedMigrationsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SeedMigrations entities.
func (c *SeedMigrationsClient) CreateBulk(builders ...*SeedMigrationsCreate) *SeedMigrationsCreateBulk {
	return &SeedMigrationsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SeedMigrations.
func (c *SeedMigrationsClient) Update() *SeedMigrationsUpdate {
	mutation := newSeedMigrationsMutation(c.config, OpUpdate)
	return &SeedMigrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeedMigrationsClient) UpdateOne(sm *SeedMigrations) *SeedMigrationsUpdateOne {
	mutation := newSeedMigrationsMutation(c.config, OpUpdateOne, withSeedMigrations(sm))
	return &SeedMigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeedMigrationsClient) UpdateOneID(id int) *SeedMigrationsUpdateOne {
	mutation := newSeedMigrationsMutation(c.config, OpUpdateOne, withSeedMigrationsID(id))
	return &SeedMigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SeedMigrations.
func (c *SeedMigrationsClient) Delete() *SeedMigrationsDelete {
	mutation := newSeedMigrationsMutation(c.config, OpDelete)
	return &SeedMigrationsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeedMigrationsClient) DeleteOne(sm *SeedMigrations) *SeedMigrationsDeleteOne {
	return c.DeleteOneID(sm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeedMigrationsClient) DeleteOneID(id int) *SeedMigrationsDeleteOne {
	builder := c.Delete().Where(seedmigrations.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeedMigrationsDeleteOne{builder}
}

// Query returns a query builder for SeedMigrations.
func (c *SeedMigrationsClient) Query() *SeedMigrationsQuery {
	return &SeedMigrationsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeedMigrations},
		inters: c.Interceptors(),
	}
}

// Get returns a SeedMigrations entity by its id.
func (c *SeedMigrationsClient) Get(ctx context.Context, id int) (*SeedMigrations, error) {
	return c.Query().Where(seedmigrations.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeedMigrationsClient) GetX(ctx context.Context, id int) *SeedMigrations {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SeedMigrationsClient) Hooks() []Hook {
	hooks := c.hooks.SeedMigrations
	return append(hooks[:len(hooks):len(hooks)], seedmigrations.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *SeedMigrationsClient) Interceptors() []Interceptor {
	return c.inters.SeedMigrations
}

func (c *SeedMigrationsClient) mutate(ctx context.Context, m *SeedMigrationsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeedMigrationsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeedMigrationsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeedMigrationsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeedMigrationsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SeedMigrations mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a User.
func (c *UserClient) QueryRoles(u *User) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.RolesTable, user.RolesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFiles queries the files edge of a User.
func (c *UserClient) QueryFiles(u *User) *FileQuery {
	query := (&FileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(file.Table, file.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FilesTable, user.FilesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComments queries the comments edge of a User.
func (c *UserClient) QueryComments(u *User) *CommentQuery {
	query := (&CommentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(comment.Table, comment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CommentsTable, user.CommentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	hooks := c.hooks.User
	return append(hooks[:len(hooks):len(hooks)], user.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	inters := c.inters.User
	return append(inters[:len(inters):len(inters)], user.Interceptors[:]...)
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Chapter, ChapterText, Comment, File, Migrations, Part, Permission, Release,
		Role, SeedMigrations, User []ent.Hook
	}
	inters struct {
		Chapter, ChapterText, Comment, File, Migrations, Part, Permission, Release,
		Role, SeedMigrations, User []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
