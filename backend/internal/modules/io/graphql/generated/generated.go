// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
	models1 "waterfall-backend/internal/models"
	"waterfall-backend/internal/models/files"
	"waterfall-backend/internal/models/permissions"
	"waterfall-backend/internal/models/roles"
	"waterfall-backend/internal/modules/domain/chapter/dto"
	dto1 "waterfall-backend/internal/modules/domain/comment/dto"
	dto2 "waterfall-backend/internal/modules/domain/part/dto"
	dto3 "waterfall-backend/internal/modules/domain/release/dto"
	dto4 "waterfall-backend/internal/modules/domain/user/dto"
	"waterfall-backend/internal/modules/io/graphql/models"
	dto5 "waterfall-backend/internal/modules/services/fs/dto"
	"waterfall-backend/internal/pkg/optional"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Chapter() ChapterResolver
	Comment() CommentResolver
	Mutation() MutationResolver
	Part() PartResolver
	Query() QueryResolver
	Role() RoleResolver
	User() UserResolver
	OptionalID() OptionalIDResolver
	OptionalInt() OptionalIntResolver
	OptionalString() OptionalStringResolver
	OptionalStringSlice() OptionalStringSliceResolver
	UserUpdate() UserUpdateResolver
}

type DirectiveRoot struct {
	IgnoreReleaseDate func(ctx context.Context, obj interface{}, next graphql.Resolver, availableFields []string) (res interface{}, err error)
	Permission        func(ctx context.Context, obj interface{}, next graphql.Resolver, permission *permissions.Type) (res interface{}, err error)
	Protect           func(ctx context.Context, obj interface{}, next graphql.Resolver, protectedFields []string) (res interface{}, err error)
}

type ComplexityRoot struct {
	Chapter struct {
		Attachments func(childComplexity int) int
		AvailableAt func(childComplexity int) int
		Comments    func(childComplexity int) int
		NextID      func(childComplexity int) int
		Number      func(childComplexity int) int
		Part        func(childComplexity int) int
		PrevID      func(childComplexity int) int
		Ref         func(childComplexity int) int
		ReleaseInfo func(childComplexity int) int
		String      func(childComplexity int) int
		Text        func(childComplexity int) int
		Title       func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	ChapterText struct {
		ChapterUuid func(childComplexity int) int
		Text        func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	Comment struct {
		Author      func(childComplexity int) int
		ChapterUuid func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ParentUuid  func(childComplexity int) int
		Text        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	File struct {
		CreatorUuid    func(childComplexity int) int
		Description    func(childComplexity int) int
		Filename       func(childComplexity int) int
		MIMEType       func(childComplexity int) int
		ObjectRef      func(childComplexity int) int
		SequenceNumber func(childComplexity int) int
		Temp           func(childComplexity int) int
		Type           func(childComplexity int) int
		Uuid           func(childComplexity int) int
	}

	Mutation struct {
		ChapterCreate         func(childComplexity int, chapter dto.ChapterCreate) int
		ChapterDelete         func(childComplexity int, id string) int
		ChapterTextCreate     func(childComplexity int, chapterText dto.ChapterTextCreate) int
		ChapterTextDelete     func(childComplexity int, id string) int
		ChapterTextUpdate     func(childComplexity int, id string, chapterText dto.ChapterTextUpdate) int
		ChapterUpdate         func(childComplexity int, id string, chapter dto.ChapterUpdate) int
		CommentCreate         func(childComplexity int, chapter dto1.CommentCreate) int
		CommentDelete         func(childComplexity int, id string) int
		CommentUpdate         func(childComplexity int, id string, chapter dto1.CommentUpdate) int
		FilesDelete           func(childComplexity int, ids []string) int
		FilesMakeNotTemp      func(childComplexity int, ids []string) int
		FilesReorder          func(childComplexity int, ids []string) int
		PartCreate            func(childComplexity int, part dto2.PartCreate) int
		PartDelete            func(childComplexity int, id string) int
		PartUpdate            func(childComplexity int, id string, part dto2.PartUpdate) int
		Ping                  func(childComplexity int) int
		ReleaseCreate         func(childComplexity int, release dto3.ReleaseCreate) int
		ReleaseDelete         func(childComplexity int, id string) int
		ReleaseUpdate         func(childComplexity int, id string, release dto3.ReleaseUpdate) int
		ScheduleReleaseCreate func(childComplexity int, release dto3.ReleaseCreate, scheduleAt time.Time) int
		UserAddRole           func(childComplexity int, id string, role roles.Type) int
		UserDelete            func(childComplexity int, id string) int
		UserDeleteSelf        func(childComplexity int) int
		UserRemoveRole        func(childComplexity int, id string, role roles.Type) int
		UserUpdate            func(childComplexity int, id string, updateUser dto4.UserUpdate) int
		UserUpdateSelf        func(childComplexity int, updateUser dto4.UserUpdate) int
	}

	ObjectRef struct {
		Ref  func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Part struct {
		Annotation  func(childComplexity int) int
		AvailableAt func(childComplexity int) int
		Chapters    func(childComplexity int, sortOrder *models.SortOrder) int
		Number      func(childComplexity int) int
		Ref         func(childComplexity int) int
		ReleaseInfo func(childComplexity int) int
		String      func(childComplexity int) int
		Title       func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	Query struct {
		ChapterFirstID         func(childComplexity int) int
		ChapterGet             func(childComplexity int, id string) int
		ChapterLastAvailableAt func(childComplexity int) int
		ChapterLastAvailableID func(childComplexity int) int
		ChapterList            func(childComplexity int) int
		ChapterNextID          func(childComplexity int, id string) int
		ChapterPrevID          func(childComplexity int, id string) int
		ChapterTextGet         func(childComplexity int, id string) int
		CommentGet             func(childComplexity int, id string) int
		CommentListByChapter   func(childComplexity int, chapterID string) int
		PartGet                func(childComplexity int, id string) int
		PartList               func(childComplexity int, sortOrder *models.SortOrder) int
		Ping                   func(childComplexity int) int
		ReleaseGet             func(childComplexity int, id string) int
		ReleaseList            func(childComplexity int) int
		UserGet                func(childComplexity int, id string) int
		UserGetSelf            func(childComplexity int) int
		UserList               func(childComplexity int) int
	}

	Release struct {
		Description func(childComplexity int) int
		Releasables func(childComplexity int) int
		ReleaseDate func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	ReleaseInfo struct {
		Description func(childComplexity int) int
		ReleaseDate func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	Role struct {
		Description  func(childComplexity int) int
		Id           func(childComplexity int) int
		ReleaseDelay func(childComplexity int) int
	}

	User struct {
		Attachments func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Email       func(childComplexity int) int
		Fullname    func(childComplexity int) int
		Roles       func(childComplexity int) int
		Score       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Username    func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}
}

type ChapterResolver interface {
	Part(ctx context.Context, obj *dto.Chapter) (*dto2.Part, error)
	Text(ctx context.Context, obj *dto.Chapter) (*dto.ChapterText, error)
	Attachments(ctx context.Context, obj *dto.Chapter) ([]*dto5.File, error)
	Comments(ctx context.Context, obj *dto.Chapter) ([]*dto1.Comment, error)
	NextID(ctx context.Context, obj *dto.Chapter) (*string, error)
	PrevID(ctx context.Context, obj *dto.Chapter) (*string, error)

	ReleaseInfo(ctx context.Context, obj *dto.Chapter) (*dto3.Release, error)
	AvailableAt(ctx context.Context, obj *dto.Chapter) (*time.Time, error)
}
type CommentResolver interface {
	Author(ctx context.Context, obj *dto1.Comment) (*dto4.User, error)
}
type MutationResolver interface {
	Ping(ctx context.Context) (string, error)
	ChapterCreate(ctx context.Context, chapter dto.ChapterCreate) (*dto.Chapter, error)
	ChapterUpdate(ctx context.Context, id string, chapter dto.ChapterUpdate) (*dto.Chapter, error)
	ChapterDelete(ctx context.Context, id string) (string, error)
	ChapterTextCreate(ctx context.Context, chapterText dto.ChapterTextCreate) (*dto.ChapterText, error)
	ChapterTextUpdate(ctx context.Context, id string, chapterText dto.ChapterTextUpdate) (*dto.ChapterText, error)
	ChapterTextDelete(ctx context.Context, id string) (string, error)
	CommentCreate(ctx context.Context, chapter dto1.CommentCreate) (*dto1.Comment, error)
	CommentUpdate(ctx context.Context, id string, chapter dto1.CommentUpdate) (*dto1.Comment, error)
	CommentDelete(ctx context.Context, id string) (string, error)
	FilesMakeNotTemp(ctx context.Context, ids []string) ([]string, error)
	FilesDelete(ctx context.Context, ids []string) ([]string, error)
	FilesReorder(ctx context.Context, ids []string) ([]string, error)
	PartCreate(ctx context.Context, part dto2.PartCreate) (*dto2.Part, error)
	PartUpdate(ctx context.Context, id string, part dto2.PartUpdate) (*dto2.Part, error)
	PartDelete(ctx context.Context, id string) (string, error)
	ReleaseCreate(ctx context.Context, release dto3.ReleaseCreate) (*dto3.Release, error)
	ReleaseUpdate(ctx context.Context, id string, release dto3.ReleaseUpdate) (*dto3.Release, error)
	ReleaseDelete(ctx context.Context, id string) (string, error)
	ScheduleReleaseCreate(ctx context.Context, release dto3.ReleaseCreate, scheduleAt time.Time) (string, error)
	UserUpdateSelf(ctx context.Context, updateUser dto4.UserUpdate) (*dto4.User, error)
	UserUpdate(ctx context.Context, id string, updateUser dto4.UserUpdate) (*dto4.User, error)
	UserDeleteSelf(ctx context.Context) (string, error)
	UserDelete(ctx context.Context, id string) (string, error)
	UserAddRole(ctx context.Context, id string, role roles.Type) ([]*dto4.Role, error)
	UserRemoveRole(ctx context.Context, id string, role roles.Type) ([]*dto4.Role, error)
}
type PartResolver interface {
	Chapters(ctx context.Context, obj *dto2.Part, sortOrder *models.SortOrder) ([]*dto.Chapter, error)

	ReleaseInfo(ctx context.Context, obj *dto2.Part) (*dto3.Release, error)
	AvailableAt(ctx context.Context, obj *dto2.Part) (*time.Time, error)
}
type QueryResolver interface {
	Ping(ctx context.Context) (string, error)
	ChapterGet(ctx context.Context, id string) (*dto.Chapter, error)
	ChapterList(ctx context.Context) ([]*dto.Chapter, error)
	ChapterNextID(ctx context.Context, id string) (*string, error)
	ChapterPrevID(ctx context.Context, id string) (*string, error)
	ChapterFirstID(ctx context.Context) (string, error)
	ChapterLastAvailableID(ctx context.Context) (string, error)
	ChapterLastAvailableAt(ctx context.Context) (*time.Time, error)
	ChapterTextGet(ctx context.Context, id string) (*dto.ChapterText, error)
	CommentGet(ctx context.Context, id string) (*dto1.Comment, error)
	CommentListByChapter(ctx context.Context, chapterID string) ([]*dto1.Comment, error)
	PartGet(ctx context.Context, id string) (*dto2.Part, error)
	PartList(ctx context.Context, sortOrder *models.SortOrder) ([]*dto2.Part, error)
	ReleaseGet(ctx context.Context, id string) (*dto3.Release, error)
	ReleaseList(ctx context.Context) ([]*dto3.Release, error)
	UserGet(ctx context.Context, id string) (*dto4.User, error)
	UserGetSelf(ctx context.Context) (*dto4.User, error)
	UserList(ctx context.Context) ([]*dto4.User, error)
}
type RoleResolver interface {
	ReleaseDelay(ctx context.Context, obj *dto4.Role) (string, error)
}
type UserResolver interface {
	Roles(ctx context.Context, obj *dto4.User) ([]*dto4.Role, error)
	Attachments(ctx context.Context, obj *dto4.User) ([]*dto5.File, error)
}

type OptionalIDResolver interface {
	Value(ctx context.Context, obj *optional.Variable[string], data *string) error
}
type OptionalIntResolver interface {
	Value(ctx context.Context, obj *optional.Variable[int], data *int) error
}
type OptionalStringResolver interface {
	Value(ctx context.Context, obj *optional.Variable[string], data *string) error
}
type OptionalStringSliceResolver interface {
	Value(ctx context.Context, obj *optional.Variable[[]string], data []string) error
}
type UserUpdateResolver interface {
	Fullname(ctx context.Context, obj *dto4.UserUpdate, data string) error
	Username(ctx context.Context, obj *dto4.UserUpdate, data string) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Chapter.Attachments":
		if e.complexity.Chapter.Attachments == nil {
			break
		}

		return e.complexity.Chapter.Attachments(childComplexity), true

	case "Chapter.AvailableAt":
		if e.complexity.Chapter.AvailableAt == nil {
			break
		}

		return e.complexity.Chapter.AvailableAt(childComplexity), true

	case "Chapter.Comments":
		if e.complexity.Chapter.Comments == nil {
			break
		}

		return e.complexity.Chapter.Comments(childComplexity), true

	case "Chapter.NextID":
		if e.complexity.Chapter.NextID == nil {
			break
		}

		return e.complexity.Chapter.NextID(childComplexity), true

	case "Chapter.Number":
		if e.complexity.Chapter.Number == nil {
			break
		}

		return e.complexity.Chapter.Number(childComplexity), true

	case "Chapter.Part":
		if e.complexity.Chapter.Part == nil {
			break
		}

		return e.complexity.Chapter.Part(childComplexity), true

	case "Chapter.PrevID":
		if e.complexity.Chapter.PrevID == nil {
			break
		}

		return e.complexity.Chapter.PrevID(childComplexity), true

	case "Chapter.Ref":
		if e.complexity.Chapter.Ref == nil {
			break
		}

		return e.complexity.Chapter.Ref(childComplexity), true

	case "Chapter.ReleaseInfo":
		if e.complexity.Chapter.ReleaseInfo == nil {
			break
		}

		return e.complexity.Chapter.ReleaseInfo(childComplexity), true

	case "Chapter.String":
		if e.complexity.Chapter.String == nil {
			break
		}

		return e.complexity.Chapter.String(childComplexity), true

	case "Chapter.Text":
		if e.complexity.Chapter.Text == nil {
			break
		}

		return e.complexity.Chapter.Text(childComplexity), true

	case "Chapter.Title":
		if e.complexity.Chapter.Title == nil {
			break
		}

		return e.complexity.Chapter.Title(childComplexity), true

	case "Chapter.ID":
		if e.complexity.Chapter.Uuid == nil {
			break
		}

		return e.complexity.Chapter.Uuid(childComplexity), true

	case "ChapterText.ChapterID":
		if e.complexity.ChapterText.ChapterUuid == nil {
			break
		}

		return e.complexity.ChapterText.ChapterUuid(childComplexity), true

	case "ChapterText.Text":
		if e.complexity.ChapterText.Text == nil {
			break
		}

		return e.complexity.ChapterText.Text(childComplexity), true

	case "ChapterText.ID":
		if e.complexity.ChapterText.Uuid == nil {
			break
		}

		return e.complexity.ChapterText.Uuid(childComplexity), true

	case "Comment.Author":
		if e.complexity.Comment.Author == nil {
			break
		}

		return e.complexity.Comment.Author(childComplexity), true

	case "Comment.ChapterID":
		if e.complexity.Comment.ChapterUuid == nil {
			break
		}

		return e.complexity.Comment.ChapterUuid(childComplexity), true

	case "Comment.CreatedAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.ParentID":
		if e.complexity.Comment.ParentUuid == nil {
			break
		}

		return e.complexity.Comment.ParentUuid(childComplexity), true

	case "Comment.Text":
		if e.complexity.Comment.Text == nil {
			break
		}

		return e.complexity.Comment.Text(childComplexity), true

	case "Comment.UpdatedAt":
		if e.complexity.Comment.UpdatedAt == nil {
			break
		}

		return e.complexity.Comment.UpdatedAt(childComplexity), true

	case "Comment.ID":
		if e.complexity.Comment.Uuid == nil {
			break
		}

		return e.complexity.Comment.Uuid(childComplexity), true

	case "File.CreatorID":
		if e.complexity.File.CreatorUuid == nil {
			break
		}

		return e.complexity.File.CreatorUuid(childComplexity), true

	case "File.Description":
		if e.complexity.File.Description == nil {
			break
		}

		return e.complexity.File.Description(childComplexity), true

	case "File.Filename":
		if e.complexity.File.Filename == nil {
			break
		}

		return e.complexity.File.Filename(childComplexity), true

	case "File.MIMEType":
		if e.complexity.File.MIMEType == nil {
			break
		}

		return e.complexity.File.MIMEType(childComplexity), true

	case "File.ObjectRef":
		if e.complexity.File.ObjectRef == nil {
			break
		}

		return e.complexity.File.ObjectRef(childComplexity), true

	case "File.SequenceNumber":
		if e.complexity.File.SequenceNumber == nil {
			break
		}

		return e.complexity.File.SequenceNumber(childComplexity), true

	case "File.Temp":
		if e.complexity.File.Temp == nil {
			break
		}

		return e.complexity.File.Temp(childComplexity), true

	case "File.Type":
		if e.complexity.File.Type == nil {
			break
		}

		return e.complexity.File.Type(childComplexity), true

	case "File.ID":
		if e.complexity.File.Uuid == nil {
			break
		}

		return e.complexity.File.Uuid(childComplexity), true

	case "Mutation.ChapterCreate":
		if e.complexity.Mutation.ChapterCreate == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterCreate(childComplexity, args["chapter"].(dto.ChapterCreate)), true

	case "Mutation.ChapterDelete":
		if e.complexity.Mutation.ChapterDelete == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterDelete(childComplexity, args["id"].(string)), true

	case "Mutation.ChapterTextCreate":
		if e.complexity.Mutation.ChapterTextCreate == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterTextCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterTextCreate(childComplexity, args["chapterText"].(dto.ChapterTextCreate)), true

	case "Mutation.ChapterTextDelete":
		if e.complexity.Mutation.ChapterTextDelete == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterTextDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterTextDelete(childComplexity, args["id"].(string)), true

	case "Mutation.ChapterTextUpdate":
		if e.complexity.Mutation.ChapterTextUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterTextUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterTextUpdate(childComplexity, args["id"].(string), args["chapterText"].(dto.ChapterTextUpdate)), true

	case "Mutation.ChapterUpdate":
		if e.complexity.Mutation.ChapterUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_ChapterUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChapterUpdate(childComplexity, args["id"].(string), args["chapter"].(dto.ChapterUpdate)), true

	case "Mutation.CommentCreate":
		if e.complexity.Mutation.CommentCreate == nil {
			break
		}

		args, err := ec.field_Mutation_CommentCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CommentCreate(childComplexity, args["chapter"].(dto1.CommentCreate)), true

	case "Mutation.CommentDelete":
		if e.complexity.Mutation.CommentDelete == nil {
			break
		}

		args, err := ec.field_Mutation_CommentDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CommentDelete(childComplexity, args["id"].(string)), true

	case "Mutation.CommentUpdate":
		if e.complexity.Mutation.CommentUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_CommentUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CommentUpdate(childComplexity, args["id"].(string), args["chapter"].(dto1.CommentUpdate)), true

	case "Mutation.FilesDelete":
		if e.complexity.Mutation.FilesDelete == nil {
			break
		}

		args, err := ec.field_Mutation_FilesDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FilesDelete(childComplexity, args["ids"].([]string)), true

	case "Mutation.FilesMakeNotTemp":
		if e.complexity.Mutation.FilesMakeNotTemp == nil {
			break
		}

		args, err := ec.field_Mutation_FilesMakeNotTemp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FilesMakeNotTemp(childComplexity, args["ids"].([]string)), true

	case "Mutation.FilesReorder":
		if e.complexity.Mutation.FilesReorder == nil {
			break
		}

		args, err := ec.field_Mutation_FilesReorder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FilesReorder(childComplexity, args["ids"].([]string)), true

	case "Mutation.PartCreate":
		if e.complexity.Mutation.PartCreate == nil {
			break
		}

		args, err := ec.field_Mutation_PartCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PartCreate(childComplexity, args["part"].(dto2.PartCreate)), true

	case "Mutation.PartDelete":
		if e.complexity.Mutation.PartDelete == nil {
			break
		}

		args, err := ec.field_Mutation_PartDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PartDelete(childComplexity, args["id"].(string)), true

	case "Mutation.PartUpdate":
		if e.complexity.Mutation.PartUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_PartUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PartUpdate(childComplexity, args["id"].(string), args["part"].(dto2.PartUpdate)), true

	case "Mutation.ping":
		if e.complexity.Mutation.Ping == nil {
			break
		}

		return e.complexity.Mutation.Ping(childComplexity), true

	case "Mutation.ReleaseCreate":
		if e.complexity.Mutation.ReleaseCreate == nil {
			break
		}

		args, err := ec.field_Mutation_ReleaseCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReleaseCreate(childComplexity, args["release"].(dto3.ReleaseCreate)), true

	case "Mutation.ReleaseDelete":
		if e.complexity.Mutation.ReleaseDelete == nil {
			break
		}

		args, err := ec.field_Mutation_ReleaseDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReleaseDelete(childComplexity, args["id"].(string)), true

	case "Mutation.ReleaseUpdate":
		if e.complexity.Mutation.ReleaseUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_ReleaseUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReleaseUpdate(childComplexity, args["id"].(string), args["release"].(dto3.ReleaseUpdate)), true

	case "Mutation.ScheduleReleaseCreate":
		if e.complexity.Mutation.ScheduleReleaseCreate == nil {
			break
		}

		args, err := ec.field_Mutation_ScheduleReleaseCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleReleaseCreate(childComplexity, args["release"].(dto3.ReleaseCreate), args["scheduleAt"].(time.Time)), true

	case "Mutation.UserAddRole":
		if e.complexity.Mutation.UserAddRole == nil {
			break
		}

		args, err := ec.field_Mutation_UserAddRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserAddRole(childComplexity, args["id"].(string), args["role"].(roles.Type)), true

	case "Mutation.UserDelete":
		if e.complexity.Mutation.UserDelete == nil {
			break
		}

		args, err := ec.field_Mutation_UserDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDelete(childComplexity, args["id"].(string)), true

	case "Mutation.UserDeleteSelf":
		if e.complexity.Mutation.UserDeleteSelf == nil {
			break
		}

		return e.complexity.Mutation.UserDeleteSelf(childComplexity), true

	case "Mutation.UserRemoveRole":
		if e.complexity.Mutation.UserRemoveRole == nil {
			break
		}

		args, err := ec.field_Mutation_UserRemoveRole_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserRemoveRole(childComplexity, args["id"].(string), args["role"].(roles.Type)), true

	case "Mutation.UserUpdate":
		if e.complexity.Mutation.UserUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_UserUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdate(childComplexity, args["id"].(string), args["updateUser"].(dto4.UserUpdate)), true

	case "Mutation.UserUpdateSelf":
		if e.complexity.Mutation.UserUpdateSelf == nil {
			break
		}

		args, err := ec.field_Mutation_UserUpdateSelf_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserUpdateSelf(childComplexity, args["updateUser"].(dto4.UserUpdate)), true

	case "ObjectRef.Ref":
		if e.complexity.ObjectRef.Ref == nil {
			break
		}

		return e.complexity.ObjectRef.Ref(childComplexity), true

	case "ObjectRef.Type":
		if e.complexity.ObjectRef.Type == nil {
			break
		}

		return e.complexity.ObjectRef.Type(childComplexity), true

	case "Part.Annotation":
		if e.complexity.Part.Annotation == nil {
			break
		}

		return e.complexity.Part.Annotation(childComplexity), true

	case "Part.AvailableAt":
		if e.complexity.Part.AvailableAt == nil {
			break
		}

		return e.complexity.Part.AvailableAt(childComplexity), true

	case "Part.Chapters":
		if e.complexity.Part.Chapters == nil {
			break
		}

		args, err := ec.field_Part_Chapters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Part.Chapters(childComplexity, args["sortOrder"].(*models.SortOrder)), true

	case "Part.Number":
		if e.complexity.Part.Number == nil {
			break
		}

		return e.complexity.Part.Number(childComplexity), true

	case "Part.Ref":
		if e.complexity.Part.Ref == nil {
			break
		}

		return e.complexity.Part.Ref(childComplexity), true

	case "Part.ReleaseInfo":
		if e.complexity.Part.ReleaseInfo == nil {
			break
		}

		return e.complexity.Part.ReleaseInfo(childComplexity), true

	case "Part.String":
		if e.complexity.Part.String == nil {
			break
		}

		return e.complexity.Part.String(childComplexity), true

	case "Part.Title":
		if e.complexity.Part.Title == nil {
			break
		}

		return e.complexity.Part.Title(childComplexity), true

	case "Part.ID":
		if e.complexity.Part.Uuid == nil {
			break
		}

		return e.complexity.Part.Uuid(childComplexity), true

	case "Query.ChapterFirstID":
		if e.complexity.Query.ChapterFirstID == nil {
			break
		}

		return e.complexity.Query.ChapterFirstID(childComplexity), true

	case "Query.ChapterGet":
		if e.complexity.Query.ChapterGet == nil {
			break
		}

		args, err := ec.field_Query_ChapterGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChapterGet(childComplexity, args["id"].(string)), true

	case "Query.ChapterLastAvailableAt":
		if e.complexity.Query.ChapterLastAvailableAt == nil {
			break
		}

		return e.complexity.Query.ChapterLastAvailableAt(childComplexity), true

	case "Query.ChapterLastAvailableID":
		if e.complexity.Query.ChapterLastAvailableID == nil {
			break
		}

		return e.complexity.Query.ChapterLastAvailableID(childComplexity), true

	case "Query.ChapterList":
		if e.complexity.Query.ChapterList == nil {
			break
		}

		return e.complexity.Query.ChapterList(childComplexity), true

	case "Query.ChapterNextID":
		if e.complexity.Query.ChapterNextID == nil {
			break
		}

		args, err := ec.field_Query_ChapterNextID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChapterNextID(childComplexity, args["id"].(string)), true

	case "Query.ChapterPrevID":
		if e.complexity.Query.ChapterPrevID == nil {
			break
		}

		args, err := ec.field_Query_ChapterPrevID_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChapterPrevID(childComplexity, args["id"].(string)), true

	case "Query.ChapterTextGet":
		if e.complexity.Query.ChapterTextGet == nil {
			break
		}

		args, err := ec.field_Query_ChapterTextGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ChapterTextGet(childComplexity, args["id"].(string)), true

	case "Query.CommentGet":
		if e.complexity.Query.CommentGet == nil {
			break
		}

		args, err := ec.field_Query_CommentGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CommentGet(childComplexity, args["id"].(string)), true

	case "Query.CommentListByChapter":
		if e.complexity.Query.CommentListByChapter == nil {
			break
		}

		args, err := ec.field_Query_CommentListByChapter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CommentListByChapter(childComplexity, args["chapterID"].(string)), true

	case "Query.PartGet":
		if e.complexity.Query.PartGet == nil {
			break
		}

		args, err := ec.field_Query_PartGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PartGet(childComplexity, args["id"].(string)), true

	case "Query.PartList":
		if e.complexity.Query.PartList == nil {
			break
		}

		args, err := ec.field_Query_PartList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PartList(childComplexity, args["sortOrder"].(*models.SortOrder)), true

	case "Query.ping":
		if e.complexity.Query.Ping == nil {
			break
		}

		return e.complexity.Query.Ping(childComplexity), true

	case "Query.ReleaseGet":
		if e.complexity.Query.ReleaseGet == nil {
			break
		}

		args, err := ec.field_Query_ReleaseGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ReleaseGet(childComplexity, args["id"].(string)), true

	case "Query.ReleaseList":
		if e.complexity.Query.ReleaseList == nil {
			break
		}

		return e.complexity.Query.ReleaseList(childComplexity), true

	case "Query.UserGet":
		if e.complexity.Query.UserGet == nil {
			break
		}

		args, err := ec.field_Query_UserGet_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserGet(childComplexity, args["id"].(string)), true

	case "Query.UserGetSelf":
		if e.complexity.Query.UserGetSelf == nil {
			break
		}

		return e.complexity.Query.UserGetSelf(childComplexity), true

	case "Query.UserList":
		if e.complexity.Query.UserList == nil {
			break
		}

		return e.complexity.Query.UserList(childComplexity), true

	case "Release.Description":
		if e.complexity.Release.Description == nil {
			break
		}

		return e.complexity.Release.Description(childComplexity), true

	case "Release.Releasables":
		if e.complexity.Release.Releasables == nil {
			break
		}

		return e.complexity.Release.Releasables(childComplexity), true

	case "Release.ReleaseDate":
		if e.complexity.Release.ReleaseDate == nil {
			break
		}

		return e.complexity.Release.ReleaseDate(childComplexity), true

	case "Release.ID":
		if e.complexity.Release.Uuid == nil {
			break
		}

		return e.complexity.Release.Uuid(childComplexity), true

	case "ReleaseInfo.Description":
		if e.complexity.ReleaseInfo.Description == nil {
			break
		}

		return e.complexity.ReleaseInfo.Description(childComplexity), true

	case "ReleaseInfo.ReleaseDate":
		if e.complexity.ReleaseInfo.ReleaseDate == nil {
			break
		}

		return e.complexity.ReleaseInfo.ReleaseDate(childComplexity), true

	case "ReleaseInfo.ID":
		if e.complexity.ReleaseInfo.Uuid == nil {
			break
		}

		return e.complexity.ReleaseInfo.Uuid(childComplexity), true

	case "Role.Description":
		if e.complexity.Role.Description == nil {
			break
		}

		return e.complexity.Role.Description(childComplexity), true

	case "Role.ID":
		if e.complexity.Role.Id == nil {
			break
		}

		return e.complexity.Role.Id(childComplexity), true

	case "Role.ReleaseDelay":
		if e.complexity.Role.ReleaseDelay == nil {
			break
		}

		return e.complexity.Role.ReleaseDelay(childComplexity), true

	case "User.Attachments":
		if e.complexity.User.Attachments == nil {
			break
		}

		return e.complexity.User.Attachments(childComplexity), true

	case "User.CreatedAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.DeletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.Email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.Fullname":
		if e.complexity.User.Fullname == nil {
			break
		}

		return e.complexity.User.Fullname(childComplexity), true

	case "User.Roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.Score":
		if e.complexity.User.Score == nil {
			break
		}

		return e.complexity.User.Score(childComplexity), true

	case "User.UpdatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.Username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "User.ID":
		if e.complexity.User.Uuid == nil {
			break
		}

		return e.complexity.User.Uuid(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputChapterCreate,
		ec.unmarshalInputChapterTextCreate,
		ec.unmarshalInputChapterTextUpdate,
		ec.unmarshalInputChapterUpdate,
		ec.unmarshalInputCommentCreate,
		ec.unmarshalInputCommentUpdate,
		ec.unmarshalInputObjectRefInput,
		ec.unmarshalInputOptionalID,
		ec.unmarshalInputOptionalInt,
		ec.unmarshalInputOptionalString,
		ec.unmarshalInputOptionalStringSlice,
		ec.unmarshalInputPartCreate,
		ec.unmarshalInputPartUpdate,
		ec.unmarshalInputReleaseCreate,
		ec.unmarshalInputReleaseUpdate,
		ec.unmarshalInputUserUpdate,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/chapter.graphql", Input: `extend type Query {
    "Получить главу по идентификатору"
    ChapterGet(id: ID!): Chapter! @permission(permission: chapters_read)
    "Получить все главы"
    ChapterList: [Chapter!]! @permission(permission: chapters_read)
    "Получить ID следующей главы"
    ChapterNextID(id: ID!): ID @permission(permission: chapters_read)
    "Получить ID предыдущей главы"
    ChapterPrevID(id: ID!): ID @permission(permission: chapters_read)
    "Получить ID первой главы"
    ChapterFirstID: ID! @permission(permission: chapters_read)
    "Получить ID последней доступной главы"
    ChapterLastAvailableID: ID! @permission(permission: chapters_read)
    "Получить дату доступности последней доступной главы"
    ChapterLastAvailableAt: DateTime! @permission(permission: chapters_read)
}

extend type Mutation {
    "Создать главу"
    ChapterCreate(chapter: ChapterCreate!): Chapter! @permission(permission: chapters_create)
    "Обновить главу"
    ChapterUpdate(id: ID!, chapter: ChapterUpdate!): Chapter! @permission(permission: chapters_update)
    "Удалить главу"
    ChapterDelete(id: ID!): String! @permission(permission: chapters_delete)
}

"Глава"
type Chapter implements Releasable @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.Chapter")
@ignoreReleaseDate(availableFields: ["ID", "Number", "Title", "AvailableAt"]) {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "Часть, которой глава принадлежит"
    Part: Part!

    "Текст главы"
    Text: ChapterText
    "Аттачменты (файлы) главы"
    Attachments: [File!]!
    "Комментарии к главе"
    Comments: [Comment!]! @permission(permission: comments_read)


    "Получить ID следующей главы"
    NextID: ID
    "Получить ID предыдущей главы"
    PrevID: ID

    "Ссылка на этот объект"
    Ref: ObjectRef!
    "Текстовое представление объекта"
    String: String!
    "Информация о релизе (без указания выпускаемых объектов)"
    ReleaseInfo: ReleaseInfo
    "Дата, когда глава станет доступна"
    AvailableAt: DateTime
}

"Модель создания главы"
input ChapterCreate @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.ChapterCreate") {
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "ID части, которой глава принадлежит"
    PartID: ID! @goField(name: "PartUuid")
}

"Модель обновления главы"
input ChapterUpdate @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.ChapterUpdate") {
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "ID части, которой глава принадлежит"
    PartID: ID! @goField(name: "PartUuid")
}
`, BuiltIn: false},
	{Name: "../schemas/chapter_text.graphql", Input: `extend type Query {
    "Получить текст главы по идентификатору"
    ChapterTextGet(id: ID!): ChapterText! @permission(permission: chapters_read)
}

extend type Mutation {
    "Создать текст главы"
    ChapterTextCreate(chapterText: ChapterTextCreate!): ChapterText! @permission(permission: chapters_update)
    "Обновить текст главы"
    ChapterTextUpdate(id: ID!, chapterText: ChapterTextUpdate!): ChapterText! @permission(permission: chapters_update)
    "Удалить текст главы"
    ChapterTextDelete(id: ID!): String! @permission(permission: chapters_update)
}

"Текст главы"
type ChapterText @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.ChapterText") {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "ID главы, к которой принадлежит текст"
    ChapterID: ID! @goField(name: "ChapterUuid")
    "Текст главы"
    Text: String!
}

"Модель создания текста главы"
input ChapterTextCreate @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.ChapterTextCreate") {
    "ID главы, к которой принадлежит текст"
    ChapterID: ID! @goField(name: "ChapterUuid")
    "Текст главы"
    Text: String!
}

"Модель обновления текста главы"
input ChapterTextUpdate @goModel(model: "waterfall-backend/internal/modules/domain/chapter/dto.ChapterTextUpdate") {
    "Текст главы"
    Text: String!
}
`, BuiltIn: false},
	{Name: "../schemas/comment.graphql", Input: `extend type Query {
    "Получить комментарий по идентификатору"
    CommentGet(id: ID!): Comment! @permission(permission: comments_read)
    "Получить все комментарии главы, отсортированные по дате создания"
    CommentListByChapter(chapterID: ID!): [Comment!]! @permission(permission: comments_read)
}

extend type Mutation {
    "Создать комментарий"
    CommentCreate(chapter: CommentCreate!): Comment! @permission(permission: comments_create)
    "Обновить комментарий"
    CommentUpdate(id: ID!, chapter: CommentUpdate!): Comment! @permission(permission: comments_update)
    "Удалить комментарий"
    CommentDelete(id: ID!): String! @permission(permission: comments_delete)
}

"Комментарий"
type Comment @goModel(model: "waterfall-backend/internal/modules/domain/comment/dto.Comment") {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Дата создания"
    CreatedAt: DateTime!
    "Дата обновления"
    UpdatedAt: DateTime!
    "Текст комментария"
    Text: String!
    "Автор"
    Author: User!
    "Родительский комментарий"
    ParentID: ID @goField(name: "ParentUuid")
    "Глава, которой этот комментарий принадлежит"
    ChapterID: ID @goField(name: "ChapterUuid")
}

"Модель создания комментарий"
input CommentCreate @goModel(model: "waterfall-backend/internal/modules/domain/comment/dto.CommentCreate") {
    "Текст комментария"
    Text: String!
    "Родительский комментарий"
    ParentID: ID @goField(name: "ParentUuid")
    "Глава, которой этот комментарий принадлежит"
    ChapterID: ID @goField(name: "ChapterUuid")
}

"Модель обновления комментарий"
input CommentUpdate @goModel(model: "waterfall-backend/internal/modules/domain/comment/dto.CommentUpdate") {
    "Текст комментария"
    Text: String!
}
`, BuiltIn: false},
	{Name: "../schemas/directives.graphql", Input: `directive @goModel(
    model: String
    models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION | ENUM_VALUE

directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

"Определяет права доступа к запросам и мутациям"
directive @permission(permission: PermissionType) on FIELD_DEFINITION

"Определяет поля сущности, которые доступны независимо от даты релиза"
directive @ignoreReleaseDate(availableFields: [String!]!) on OBJECT

"Определяет поля сущности, которые доступны следует защитить (они будут доступны только определенным ролям или пользователям)"
directive @protect(protectedFields: [String!]!) on OBJECT`, BuiltIn: false},
	{Name: "../schemas/file.graphql", Input: `extend type Mutation {
    "Сделать несколько файлов не временными"
    FilesMakeNotTemp(ids: [ID!]!): [ID!]!
    "Удалить несколько файлов"
    FilesDelete(ids: [ID!]!): [ID!]!
    "Назначить файлам порядковые номера в соответствии с последовательностью ids"
    FilesReorder(ids: [ID!]!): [ID!]!
}

"Файл"
type File @goModel(model: "waterfall-backend/internal/modules/services/fs/dto.File") {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Имя файла"
    Filename: String!
    "MIME тип"
    MIMEType: String!
    "Описание"
    Description: String!
    "ID создателя файла"
    CreatorID: ID @goField(name: "CreatorUuid")
    "Ссылка на объект"
    ObjectRef: ObjectRef!
    "Тип файла"
    Type: FileType!
    "Признак временного файла"
    Temp: Boolean!
    "Порядковый номер файла среди всех файлов этого ObjectRef с таким типом"
    SequenceNumber: Uint
}

"Тип файла"
enum FileType @goModel(model: "waterfall-backend/internal/models/files.Type") {
    "Аватарка пользователя"
    avatar
    "Изображение (например, к главе)"
    image
}`, BuiltIn: false},
	{Name: "../schemas/object_ref.graphql", Input: `enum ObjectType @goModel(model: "waterfall-backend/internal/models.ObjectType") {
    files
    parts
    chapters
    users
}

type ObjectRef @goModel(model: "waterfall-backend/internal/models.ObjectRef") {
    Type: ObjectType!
    Ref: String!
}

input ObjectRefInput @goModel(model: "waterfall-backend/internal/models.ObjectRef") {
    Type: ObjectType!
    Ref: String!
}`, BuiltIn: false},
	{Name: "../schemas/part.graphql", Input: `extend type Query {
    "Получить часть по идентификатору"
    PartGet(id: ID!): Part! @permission(permission: parts_read)
    "Получить все части"
    PartList(sortOrder: SortOrder): [Part!]! @permission(permission: parts_read)
}

extend type Mutation {
    "Создать часть"
    PartCreate(part: PartCreate!): Part! @permission(permission: parts_create)
    "Обновить часть"
    PartUpdate(id: ID!, part: PartUpdate!): Part! @permission(permission: parts_update)
    "Удалить часть"
    PartDelete(id: ID!): String! @permission(permission: parts_delete)
}

"Часть книги"
type Part implements Releasable @goModel(model: "waterfall-backend/internal/modules/domain/part/dto.Part")
@ignoreReleaseDate(availableFields: ["ID", "Number", "Title", "AvailableAt"]) {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "Аннотация"
    Annotation: String
    "Главы"
    Chapters(sortOrder: SortOrder): [Chapter!]!

    "Ссылка на этот объект"
    Ref: ObjectRef!
    "Текстовое представление объекта"
    String: String!
    "Информация о релизе (без указания выпускаемых объектов)"
    ReleaseInfo: ReleaseInfo
    "Дата, когда часть станет доступна"
    AvailableAt: DateTime
}

"Модель создания части"
input PartCreate @goModel(model: "waterfall-backend/internal/modules/domain/part/dto.PartCreate") {
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "Аннотация"
    Annotation: String
}

"Модель обновления части"
input PartUpdate @goModel(model: "waterfall-backend/internal/modules/domain/part/dto.PartUpdate") {
    "Номер"
    Number: Int!
    "Название"
    Title: String!
    "Аннотация"
    Annotation: String
}
`, BuiltIn: false},
	{Name: "../schemas/release.graphql", Input: `extend type Query {
    "Получить релиз по идентификатору"
    ReleaseGet(id: ID!): Release! @permission(permission: releases_read)
    "Получить список релизов"
    ReleaseList: [Release!]! @permission(permission: releases_read)
}

extend type Mutation {
    "Создать релиз"
    ReleaseCreate(release: ReleaseCreate!): ReleaseInfo! @permission(permission: releases_create)
    "Обновить релиз"
    ReleaseUpdate(id: ID!, release: ReleaseUpdate!): ReleaseInfo! @permission(permission: releases_update)
    "Удалить релиз"
    ReleaseDelete(id: ID!): String! @permission(permission: releases_delete)
}

interface Releasable @goModel(model: "waterfall-backend/internal/modules/domain/release/dto.Releasable") {
    "Ссылка на объект"
    Ref: ObjectRef!
    "Текстовое представление объекта"
    String: String!
}

"Релиз"
type Release @goModel(model: "waterfall-backend/internal/modules/domain/release/dto.Release") {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Дата релиза"
    ReleaseDate: DateTime!
    "Описание"
    Description: String!
    "Список выпускаемых объектов"
    Releasables: [Releasable!]!
}

"Информация о релизе (без указания выпускаемых объектов)"
type ReleaseInfo @goModel(model: "waterfall-backend/internal/modules/domain/release/dto.Release") {
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Дата релиза"
    ReleaseDate: DateTime!
    "Описание"
    Description: String!
}


"Новый релиз"
input ReleaseCreate @goModel(model: "waterfall-backend/internal/modules/domain/release/dto.ReleaseCreate") {
    "Дата релиза"
    ReleaseDate: DateTime!
    "Описание"
    Description: String!
    "Ссылки на выпускаемые объекты"
    ObjectRefs: [ObjectRefInput!]!
}

"Модель обновления релиза"
input ReleaseUpdate @goModel(model: "waterfall-backend/internal/modules/domain/release/dto.ReleaseUpdate") {
    "Дата релиза"
    ReleaseDate: DateTime!
    "Описание"
    Description: String!
}`, BuiltIn: false},
	{Name: "../schemas/roles_permissions.graphql", Input: `enum RoleType @goModel(model: "waterfall-backend/internal/models/roles.Type") {
    admin
    premium
    free
    guest
}

enum PermissionType @goModel(model: "waterfall-backend/internal/models/permissions.Type") {
    files_read
    files_create
    releases_read
    releases_create
    releases_update
    releases_delete
    users_read
    users_read_self
    users_create
    users_update
    users_update_self
    users_delete
    users_delete_self
    chapters_read
    chapters_create
    chapters_update
    chapters_delete
    parts_read
    parts_create
    parts_update
    parts_delete
    comments_read
    comments_create
    comments_update
    comments_delete
}

type Role @goModel(model: "waterfall-backend/internal/modules/domain/user/dto.Role") {
    "Идентификатор"
    ID: RoleType! @goField(name: "Id")
    "Описание роли"
    Description: String!
    "Задержка релиза для этой роли"
    ReleaseDelay: String!
}
`, BuiltIn: false},
	{Name: "../schemas/schedule.graphql", Input: `extend type Mutation {
    "Запланировать создание релиза"
    ScheduleReleaseCreate(release: ReleaseCreate!, scheduleAt: DateTime!): String! @permission(permission: releases_create)
}
`, BuiltIn: false},
	{Name: "../schemas/types.graphql", Input: `type Query {
   ping: String!
}

type Mutation {
    ping: String!
}

scalar DateTime

scalar Uint

enum SortOrder {
    ASC
    DESC
}

"Если OptionalString не указан, то значение изменено не будет; если value не указано или равно null, то значение будет обнулено"
input OptionalString @goModel(model: "waterfall-backend/internal/pkg/optional.StringVariable") {
    value: String @goField(forceResolver: true)
}

"Если OptionalStringSlice не указан, то значение изменено не будет; если value не указано или равно null, то значение будет обнулено"
input OptionalStringSlice @goModel(model: "waterfall-backend/internal/pkg/optional.StringSliceVariable") {
    value: [String!] @goField(forceResolver: true)
}

"Если OptionalInt не указан, то значение изменено не будет; если value не указано или равно null, то значение будет обнулено"
input OptionalInt @goModel(model: "waterfall-backend/internal/pkg/optional.IntVariable") {
    value: Int @goField(forceResolver: true)
}

"Если OptionalID не указан, то значение изменено не будет; если value не указано или равно null, то значение будет обнулено"
input OptionalID @goModel(model: "waterfall-backend/internal/pkg/optional.StringVariable") {
    value: ID @goField(forceResolver: true)
}
`, BuiltIn: false},
	{Name: "../schemas/user.graphql", Input: `extend type Query {
    "Получить пользователя по идентификатору"
    UserGet(id: ID!): User! @permission(permission: users_read)
    "Получить своего пользователя"
    UserGetSelf: User! @permission(permission: users_read_self)
    "Получить список пользователей"
    UserList: [User!]! @permission(permission: users_read)
}

extend type Mutation {
    "Обновить собственный профиль"
    UserUpdateSelf(updateUser: UserUpdate!): User! @permission(permission: users_update_self)
    "Обновить пользователя"
    UserUpdate(id: ID!, updateUser: UserUpdate!): User! @permission(permission: users_update)
    "Удалить собственный профиль"
    UserDeleteSelf: ID! @permission(permission: users_delete_self)
    "Удалить пользователя"
    UserDelete(id: ID!): ID! @permission(permission: users_delete)

    "Добавить роль пользователю"
    UserAddRole(id: ID!, role: RoleType!): [Role!]! @permission(permission: users_update)
    "Забрать роль у пользователя"
    UserRemoveRole(id: ID!, role: RoleType!): [Role!]! @permission(permission: users_update)
}

"Пользователь"
type User @goModel(model: "waterfall-backend/internal/modules/domain/user/dto.User")
@protect(protectedFields: ["Email", "Roles", "Permissions"]){
    "Идентификатор"
    ID: ID! @goField(name: "Uuid")
    "Дата создания"
    CreatedAt: DateTime!
    "Дата обновления"
    UpdatedAt: DateTime!
    "Дата удаления"
    DeletedAt: DateTime
    "Email"
    Email: String
    "Полное имя"
    Fullname: String!
    "Имя пользователя в системе"
    Username: String!
    "Количество баллов"
    Score: Int!

    "Роли"
    Roles: [Role!]!

    "Аттачменты (файлы) пользователя"
    Attachments: [File!]!
}

"Модель обновления пользователя"
input UserUpdate @goModel(model: "waterfall-backend/internal/modules/domain/user/dto.UserUpdate") {
    "Полное имя"
    Fullname: String!
    "Имя пользователя в системе"
    Username: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_ignoreReleaseDate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["availableFields"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availableFields"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["availableFields"] = arg0
	return args, nil
}

func (ec *executionContext) dir_permission_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *permissions.Type
	if tmp, ok := rawArgs["permission"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permission"))
		arg0, err = ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["permission"] = arg0
	return args, nil
}

func (ec *executionContext) dir_protect_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["protectedFields"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protectedFields"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["protectedFields"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.ChapterCreate
	if tmp, ok := rawArgs["chapter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapter"))
		arg0, err = ec.unmarshalNChapterCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterTextCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto.ChapterTextCreate
	if tmp, ok := rawArgs["chapterText"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapterText"))
		arg0, err = ec.unmarshalNChapterTextCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterTextCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapterText"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterTextDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterTextUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto.ChapterTextUpdate
	if tmp, ok := rawArgs["chapterText"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapterText"))
		arg1, err = ec.unmarshalNChapterTextUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterTextUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapterText"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_ChapterUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto.ChapterUpdate
	if tmp, ok := rawArgs["chapter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapter"))
		arg1, err = ec.unmarshalNChapterUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_CommentCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto1.CommentCreate
	if tmp, ok := rawArgs["chapter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapter"))
		arg0, err = ec.unmarshalNCommentCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapter"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CommentDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CommentUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto1.CommentUpdate
	if tmp, ok := rawArgs["chapter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapter"))
		arg1, err = ec.unmarshalNCommentUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapter"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_FilesDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_FilesMakeNotTemp_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_FilesReorder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_PartCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto2.PartCreate
	if tmp, ok := rawArgs["part"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("part"))
		arg0, err = ec.unmarshalNPartCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["part"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_PartDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_PartUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto2.PartUpdate
	if tmp, ok := rawArgs["part"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("part"))
		arg1, err = ec.unmarshalNPartUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["part"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_ReleaseCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto3.ReleaseCreate
	if tmp, ok := rawArgs["release"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("release"))
		arg0, err = ec.unmarshalNReleaseCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["release"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ReleaseDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_ReleaseUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto3.ReleaseUpdate
	if tmp, ok := rawArgs["release"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("release"))
		arg1, err = ec.unmarshalNReleaseUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["release"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_ScheduleReleaseCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto3.ReleaseCreate
	if tmp, ok := rawArgs["release"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("release"))
		arg0, err = ec.unmarshalNReleaseCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseCreate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["release"] = arg0
	var arg1 time.Time
	if tmp, ok := rawArgs["scheduleAt"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scheduleAt"))
		arg1, err = ec.unmarshalNDateTime2timeᚐTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["scheduleAt"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_UserAddRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 roles.Type
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg1, err = ec.unmarshalNRoleType2waterfallᚑbackendᚋinternalᚋmodelsᚋrolesᚐType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_UserDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_UserRemoveRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 roles.Type
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg1, err = ec.unmarshalNRoleType2waterfallᚑbackendᚋinternalᚋmodelsᚋrolesᚐType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_UserUpdateSelf_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 dto4.UserUpdate
	if tmp, ok := rawArgs["updateUser"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateUser"))
		arg0, err = ec.unmarshalNUserUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUserUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateUser"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_UserUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 dto4.UserUpdate
	if tmp, ok := rawArgs["updateUser"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateUser"))
		arg1, err = ec.unmarshalNUserUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUserUpdate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateUser"] = arg1
	return args, nil
}

func (ec *executionContext) field_Part_Chapters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SortOrder
	if tmp, ok := rawArgs["sortOrder"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortOrder"))
		arg0, err = ec.unmarshalOSortOrder2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋioᚋgraphqlᚋmodelsᚐSortOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ChapterGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ChapterNextID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ChapterPrevID_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ChapterTextGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_CommentGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_CommentListByChapter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["chapterID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chapterID"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["chapterID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_PartGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_PartList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *models.SortOrder
	if tmp, ok := rawArgs["sortOrder"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortOrder"))
		arg0, err = ec.unmarshalOSortOrder2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋioᚋgraphqlᚋmodelsᚐSortOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortOrder"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ReleaseGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_UserGet_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Chapter_ID(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Number(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Title(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Part(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Part(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Chapter().Part(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, obj, directive0, availableFields)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto2.Part); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/part/dto.Part`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto2.Part)
	fc.Result = res
	return ec.marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Part(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Part_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Part_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Part_Title(ctx, field)
			case "Annotation":
				return ec.fieldContext_Part_Annotation(ctx, field)
			case "Chapters":
				return ec.fieldContext_Part_Chapters(ctx, field)
			case "Ref":
				return ec.fieldContext_Part_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Part_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Part_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Part_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Part", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Text(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().Text(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto.ChapterText)
	fc.Result = res
	return ec.marshalOChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ChapterText_ID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_ChapterText_ChapterID(ctx, field)
			case "Text":
				return ec.fieldContext_ChapterText_Text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChapterText", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Attachments(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Attachments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().Attachments(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto5.File)
	fc.Result = res
	return ec.marshalNFile2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋservicesᚋfsᚋdtoᚐFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Attachments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_File_ID(ctx, field)
			case "Filename":
				return ec.fieldContext_File_Filename(ctx, field)
			case "MIMEType":
				return ec.fieldContext_File_MIMEType(ctx, field)
			case "Description":
				return ec.fieldContext_File_Description(ctx, field)
			case "CreatorID":
				return ec.fieldContext_File_CreatorID(ctx, field)
			case "ObjectRef":
				return ec.fieldContext_File_ObjectRef(ctx, field)
			case "Type":
				return ec.fieldContext_File_Type(ctx, field)
			case "Temp":
				return ec.fieldContext_File_Temp(ctx, field)
			case "SequenceNumber":
				return ec.fieldContext_File_SequenceNumber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Comments(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Comments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Chapter().Comments(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, obj, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto1.Comment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/comment/dto.Comment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto1.Comment)
	fc.Result = res
	return ec.marshalNComment2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Comments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Comment_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_Comment_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_Comment_UpdatedAt(ctx, field)
			case "Text":
				return ec.fieldContext_Comment_Text(ctx, field)
			case "Author":
				return ec.fieldContext_Comment_Author(ctx, field)
			case "ParentID":
				return ec.fieldContext_Comment_ParentID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_Comment_ChapterID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Comment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_NextID(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_NextID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().NextID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_NextID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_PrevID(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_PrevID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().PrevID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_PrevID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_Ref(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_Ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models1.ObjectRef)
	fc.Result = res
	return ec.marshalNObjectRef2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_Ref(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Type":
				return ec.fieldContext_ObjectRef_Type(ctx, field)
			case "Ref":
				return ec.fieldContext_ObjectRef_Ref(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_String(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_String(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.String(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_String(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_ReleaseInfo(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().ReleaseInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto3.Release)
	fc.Result = res
	return ec.marshalOReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_ReleaseInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ReleaseInfo_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_ReleaseInfo_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_ReleaseInfo_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReleaseInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Chapter_AvailableAt(ctx context.Context, field graphql.CollectedField, obj *dto.Chapter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Chapter_AvailableAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Chapter().AvailableAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Chapter_AvailableAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Chapter",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChapterText_ID(ctx context.Context, field graphql.CollectedField, obj *dto.ChapterText) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChapterText_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChapterText_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChapterText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChapterText_ChapterID(ctx context.Context, field graphql.CollectedField, obj *dto.ChapterText) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChapterText_ChapterID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChapterUuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChapterText_ChapterID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChapterText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChapterText_Text(ctx context.Context, field graphql.CollectedField, obj *dto.ChapterText) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChapterText_Text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChapterText_Text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChapterText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_ID(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_CreatedAt(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_CreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_CreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_UpdatedAt(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_UpdatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_UpdatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_Text(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_Text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_Text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_Author(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_Author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Comment().Author(rctx, obj)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, obj, directive0, protectedFields)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_Author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_ParentID(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_ParentID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentUuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_ParentID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Comment_ChapterID(ctx context.Context, field graphql.CollectedField, obj *dto1.Comment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Comment_ChapterID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChapterUuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Comment_ChapterID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Comment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_ID(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_Filename(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_Filename(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filename, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_Filename(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_MIMEType(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_MIMEType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MIMEType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_MIMEType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_Description(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_CreatorID(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_CreatorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatorUuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_CreatorID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_ObjectRef(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_ObjectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models1.ObjectRef)
	fc.Result = res
	return ec.marshalNObjectRef2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_ObjectRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Type":
				return ec.fieldContext_ObjectRef_Type(ctx, field)
			case "Ref":
				return ec.fieldContext_ObjectRef_Ref(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_Type(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_Type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(files.Type)
	fc.Result = res
	return ec.marshalNFileType2waterfallᚑbackendᚋinternalᚋmodelsᚋfilesᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_Type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FileType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_Temp(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_Temp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Temp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_Temp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_SequenceNumber(ctx context.Context, field graphql.CollectedField, obj *dto5.File) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_SequenceNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SequenceNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*uint)
	fc.Result = res
	return ec.marshalOUint2ᚖuint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_SequenceNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Ping(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterCreate(rctx, fc.Args["chapter"].(dto.ChapterCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_create")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.Chapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.Chapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.Chapter)
	fc.Result = res
	return ec.marshalNChapter2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Chapter_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Chapter_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Chapter_Title(ctx, field)
			case "Part":
				return ec.fieldContext_Chapter_Part(ctx, field)
			case "Text":
				return ec.fieldContext_Chapter_Text(ctx, field)
			case "Attachments":
				return ec.fieldContext_Chapter_Attachments(ctx, field)
			case "Comments":
				return ec.fieldContext_Chapter_Comments(ctx, field)
			case "NextID":
				return ec.fieldContext_Chapter_NextID(ctx, field)
			case "PrevID":
				return ec.fieldContext_Chapter_PrevID(ctx, field)
			case "Ref":
				return ec.fieldContext_Chapter_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Chapter_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Chapter_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Chapter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterUpdate(rctx, fc.Args["id"].(string), fc.Args["chapter"].(dto.ChapterUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.Chapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.Chapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.Chapter)
	fc.Result = res
	return ec.marshalNChapter2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Chapter_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Chapter_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Chapter_Title(ctx, field)
			case "Part":
				return ec.fieldContext_Chapter_Part(ctx, field)
			case "Text":
				return ec.fieldContext_Chapter_Text(ctx, field)
			case "Attachments":
				return ec.fieldContext_Chapter_Attachments(ctx, field)
			case "Comments":
				return ec.fieldContext_Chapter_Comments(ctx, field)
			case "NextID":
				return ec.fieldContext_Chapter_NextID(ctx, field)
			case "PrevID":
				return ec.fieldContext_Chapter_PrevID(ctx, field)
			case "Ref":
				return ec.fieldContext_Chapter_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Chapter_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Chapter_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Chapter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_delete")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterTextCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterTextCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterTextCreate(rctx, fc.Args["chapterText"].(dto.ChapterTextCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.ChapterText); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.ChapterText`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.ChapterText)
	fc.Result = res
	return ec.marshalNChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterTextCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ChapterText_ID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_ChapterText_ChapterID(ctx, field)
			case "Text":
				return ec.fieldContext_ChapterText_Text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChapterText", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterTextCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterTextUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterTextUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterTextUpdate(rctx, fc.Args["id"].(string), fc.Args["chapterText"].(dto.ChapterTextUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.ChapterText); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.ChapterText`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.ChapterText)
	fc.Result = res
	return ec.marshalNChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterTextUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ChapterText_ID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_ChapterText_ChapterID(ctx, field)
			case "Text":
				return ec.fieldContext_ChapterText_Text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChapterText", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterTextUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ChapterTextDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ChapterTextDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChapterTextDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ChapterTextDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ChapterTextDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CommentCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CommentCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CommentCreate(rctx, fc.Args["chapter"].(dto1.CommentCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_create")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto1.Comment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/comment/dto.Comment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto1.Comment)
	fc.Result = res
	return ec.marshalNComment2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CommentCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Comment_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_Comment_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_Comment_UpdatedAt(ctx, field)
			case "Text":
				return ec.fieldContext_Comment_Text(ctx, field)
			case "Author":
				return ec.fieldContext_Comment_Author(ctx, field)
			case "ParentID":
				return ec.fieldContext_Comment_ParentID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_Comment_ChapterID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Comment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CommentCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CommentUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CommentUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CommentUpdate(rctx, fc.Args["id"].(string), fc.Args["chapter"].(dto1.CommentUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto1.Comment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/comment/dto.Comment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto1.Comment)
	fc.Result = res
	return ec.marshalNComment2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CommentUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Comment_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_Comment_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_Comment_UpdatedAt(ctx, field)
			case "Text":
				return ec.fieldContext_Comment_Text(ctx, field)
			case "Author":
				return ec.fieldContext_Comment_Author(ctx, field)
			case "ParentID":
				return ec.fieldContext_Comment_ParentID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_Comment_ChapterID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Comment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CommentUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CommentDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CommentDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CommentDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_delete")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CommentDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CommentDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_FilesMakeNotTemp(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_FilesMakeNotTemp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FilesMakeNotTemp(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_FilesMakeNotTemp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_FilesMakeNotTemp_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_FilesDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_FilesDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FilesDelete(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_FilesDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_FilesDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_FilesReorder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_FilesReorder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FilesReorder(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_FilesReorder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_FilesReorder_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_PartCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_PartCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PartCreate(rctx, fc.Args["part"].(dto2.PartCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "parts_create")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto2.Part); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/part/dto.Part`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto2.Part)
	fc.Result = res
	return ec.marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_PartCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Part_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Part_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Part_Title(ctx, field)
			case "Annotation":
				return ec.fieldContext_Part_Annotation(ctx, field)
			case "Chapters":
				return ec.fieldContext_Part_Chapters(ctx, field)
			case "Ref":
				return ec.fieldContext_Part_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Part_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Part_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Part_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Part", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_PartCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_PartUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_PartUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PartUpdate(rctx, fc.Args["id"].(string), fc.Args["part"].(dto2.PartUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "parts_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto2.Part); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/part/dto.Part`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto2.Part)
	fc.Result = res
	return ec.marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_PartUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Part_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Part_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Part_Title(ctx, field)
			case "Annotation":
				return ec.fieldContext_Part_Annotation(ctx, field)
			case "Chapters":
				return ec.fieldContext_Part_Chapters(ctx, field)
			case "Ref":
				return ec.fieldContext_Part_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Part_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Part_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Part_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Part", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_PartUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_PartDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_PartDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().PartDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "parts_delete")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_PartDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_PartDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ReleaseCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ReleaseCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReleaseCreate(rctx, fc.Args["release"].(dto3.ReleaseCreate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_create")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto3.Release); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/release/dto.Release`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto3.Release)
	fc.Result = res
	return ec.marshalNReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ReleaseCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ReleaseInfo_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_ReleaseInfo_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_ReleaseInfo_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReleaseInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ReleaseCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ReleaseUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ReleaseUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReleaseUpdate(rctx, fc.Args["id"].(string), fc.Args["release"].(dto3.ReleaseUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto3.Release); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/release/dto.Release`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto3.Release)
	fc.Result = res
	return ec.marshalNReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ReleaseUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ReleaseInfo_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_ReleaseInfo_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_ReleaseInfo_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReleaseInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ReleaseUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ReleaseDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ReleaseDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ReleaseDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_delete")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ReleaseDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ReleaseDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ScheduleReleaseCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ScheduleReleaseCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ScheduleReleaseCreate(rctx, fc.Args["release"].(dto3.ReleaseCreate), fc.Args["scheduleAt"].(time.Time))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_create")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ScheduleReleaseCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ScheduleReleaseCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserUpdateSelf(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserUpdateSelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserUpdateSelf(rctx, fc.Args["updateUser"].(dto4.UserUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, nil, directive0, protectedFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_update_self")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserUpdateSelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UserUpdateSelf_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserUpdate(rctx, fc.Args["id"].(string), fc.Args["updateUser"].(dto4.UserUpdate))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, nil, directive0, protectedFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UserUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserDeleteSelf(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserDeleteSelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserDeleteSelf(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_delete_self")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserDeleteSelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserDelete(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_delete")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UserDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserAddRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserAddRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserAddRole(rctx, fc.Args["id"].(string), fc.Args["role"].(roles.Type))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto4.Role); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/user/dto.Role`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto4.Role)
	fc.Result = res
	return ec.marshalNRole2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRoleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserAddRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Role_ID(ctx, field)
			case "Description":
				return ec.fieldContext_Role_Description(ctx, field)
			case "ReleaseDelay":
				return ec.fieldContext_Role_ReleaseDelay(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Role", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UserAddRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UserRemoveRole(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UserRemoveRole(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UserRemoveRole(rctx, fc.Args["id"].(string), fc.Args["role"].(roles.Type))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_update")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto4.Role); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/user/dto.Role`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto4.Role)
	fc.Result = res
	return ec.marshalNRole2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRoleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UserRemoveRole(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Role_ID(ctx, field)
			case "Description":
				return ec.fieldContext_Role_Description(ctx, field)
			case "ReleaseDelay":
				return ec.fieldContext_Role_ReleaseDelay(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Role", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UserRemoveRole_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ObjectRef_Type(ctx context.Context, field graphql.CollectedField, obj *models1.ObjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectRef_Type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models1.ObjectType)
	fc.Result = res
	return ec.marshalNObjectType2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectRef_Type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ObjectType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ObjectRef_Ref(ctx context.Context, field graphql.CollectedField, obj *models1.ObjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ObjectRef_Ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ObjectRef_Ref(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ObjectRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_ID(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_Number(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_Number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_Number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_Title(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_Title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_Title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_Annotation(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_Annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Annotation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_Annotation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_Chapters(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_Chapters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Part().Chapters(rctx, obj, fc.Args["sortOrder"].(*models.SortOrder))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, obj, directive0, availableFields)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto.Chapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/chapter/dto.Chapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto.Chapter)
	fc.Result = res
	return ec.marshalNChapter2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_Chapters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Chapter_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Chapter_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Chapter_Title(ctx, field)
			case "Part":
				return ec.fieldContext_Chapter_Part(ctx, field)
			case "Text":
				return ec.fieldContext_Chapter_Text(ctx, field)
			case "Attachments":
				return ec.fieldContext_Chapter_Attachments(ctx, field)
			case "Comments":
				return ec.fieldContext_Chapter_Comments(ctx, field)
			case "NextID":
				return ec.fieldContext_Chapter_NextID(ctx, field)
			case "PrevID":
				return ec.fieldContext_Chapter_PrevID(ctx, field)
			case "Ref":
				return ec.fieldContext_Chapter_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Chapter_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Chapter_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Chapter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Part_Chapters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Part_Ref(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_Ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models1.ObjectRef)
	fc.Result = res
	return ec.marshalNObjectRef2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_Ref(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Type":
				return ec.fieldContext_ObjectRef_Type(ctx, field)
			case "Ref":
				return ec.fieldContext_ObjectRef_Ref(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ObjectRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_String(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_String(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.String(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_String(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_ReleaseInfo(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_ReleaseInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Part().ReleaseInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*dto3.Release)
	fc.Result = res
	return ec.marshalOReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_ReleaseInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ReleaseInfo_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_ReleaseInfo_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_ReleaseInfo_Description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ReleaseInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Part_AvailableAt(ctx context.Context, field graphql.CollectedField, obj *dto2.Part) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Part_AvailableAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Part().AvailableAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Part_AvailableAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Part",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ping(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ping(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Ping(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ping(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.Chapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.Chapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.Chapter)
	fc.Result = res
	return ec.marshalNChapter2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Chapter_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Chapter_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Chapter_Title(ctx, field)
			case "Part":
				return ec.fieldContext_Chapter_Part(ctx, field)
			case "Text":
				return ec.fieldContext_Chapter_Text(ctx, field)
			case "Attachments":
				return ec.fieldContext_Chapter_Attachments(ctx, field)
			case "Comments":
				return ec.fieldContext_Chapter_Comments(ctx, field)
			case "NextID":
				return ec.fieldContext_Chapter_NextID(ctx, field)
			case "PrevID":
				return ec.fieldContext_Chapter_PrevID(ctx, field)
			case "Ref":
				return ec.fieldContext_Chapter_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Chapter_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Chapter_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Chapter", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ChapterGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto.Chapter); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/chapter/dto.Chapter`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto.Chapter)
	fc.Result = res
	return ec.marshalNChapter2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Chapter_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Chapter_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Chapter_Title(ctx, field)
			case "Part":
				return ec.fieldContext_Chapter_Part(ctx, field)
			case "Text":
				return ec.fieldContext_Chapter_Text(ctx, field)
			case "Attachments":
				return ec.fieldContext_Chapter_Attachments(ctx, field)
			case "Comments":
				return ec.fieldContext_Chapter_Comments(ctx, field)
			case "NextID":
				return ec.fieldContext_Chapter_NextID(ctx, field)
			case "PrevID":
				return ec.fieldContext_Chapter_PrevID(ctx, field)
			case "Ref":
				return ec.fieldContext_Chapter_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Chapter_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Chapter_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Chapter_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Chapter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterNextID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterNextID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterNextID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterNextID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ChapterNextID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterPrevID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterPrevID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterPrevID(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterPrevID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ChapterPrevID_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterFirstID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterFirstID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterFirstID(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterFirstID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterLastAvailableID(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterLastAvailableID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterLastAvailableID(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterLastAvailableID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterLastAvailableAt(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterLastAvailableAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterLastAvailableAt(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNDateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterLastAvailableAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ChapterTextGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ChapterTextGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ChapterTextGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "chapters_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto.ChapterText); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/chapter/dto.ChapterText`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto.ChapterText)
	fc.Result = res
	return ec.marshalNChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ChapterTextGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_ChapterText_ID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_ChapterText_ChapterID(ctx, field)
			case "Text":
				return ec.fieldContext_ChapterText_Text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChapterText", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ChapterTextGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_CommentGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_CommentGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CommentGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto1.Comment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/comment/dto.Comment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto1.Comment)
	fc.Result = res
	return ec.marshalNComment2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_CommentGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Comment_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_Comment_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_Comment_UpdatedAt(ctx, field)
			case "Text":
				return ec.fieldContext_Comment_Text(ctx, field)
			case "Author":
				return ec.fieldContext_Comment_Author(ctx, field)
			case "ParentID":
				return ec.fieldContext_Comment_ParentID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_Comment_ChapterID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Comment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_CommentGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_CommentListByChapter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_CommentListByChapter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CommentListByChapter(rctx, fc.Args["chapterID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "comments_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto1.Comment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/comment/dto.Comment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto1.Comment)
	fc.Result = res
	return ec.marshalNComment2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_CommentListByChapter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Comment_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_Comment_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_Comment_UpdatedAt(ctx, field)
			case "Text":
				return ec.fieldContext_Comment_Text(ctx, field)
			case "Author":
				return ec.fieldContext_Comment_Author(ctx, field)
			case "ParentID":
				return ec.fieldContext_Comment_ParentID(ctx, field)
			case "ChapterID":
				return ec.fieldContext_Comment_ChapterID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Comment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_CommentListByChapter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_PartGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_PartGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().PartGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "parts_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto2.Part); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/part/dto.Part`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto2.Part)
	fc.Result = res
	return ec.marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_PartGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Part_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Part_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Part_Title(ctx, field)
			case "Annotation":
				return ec.fieldContext_Part_Annotation(ctx, field)
			case "Chapters":
				return ec.fieldContext_Part_Chapters(ctx, field)
			case "Ref":
				return ec.fieldContext_Part_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Part_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Part_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Part_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Part", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_PartGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_PartList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_PartList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().PartList(rctx, fc.Args["sortOrder"].(*models.SortOrder))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			availableFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"ID", "Number", "Title", "AvailableAt"})
			if err != nil {
				return nil, err
			}
			if ec.directives.IgnoreReleaseDate == nil {
				return nil, errors.New("directive ignoreReleaseDate is not implemented")
			}
			return ec.directives.IgnoreReleaseDate(ctx, nil, directive0, availableFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "parts_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto2.Part); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/part/dto.Part`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto2.Part)
	fc.Result = res
	return ec.marshalNPart2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_PartList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Part_ID(ctx, field)
			case "Number":
				return ec.fieldContext_Part_Number(ctx, field)
			case "Title":
				return ec.fieldContext_Part_Title(ctx, field)
			case "Annotation":
				return ec.fieldContext_Part_Annotation(ctx, field)
			case "Chapters":
				return ec.fieldContext_Part_Chapters(ctx, field)
			case "Ref":
				return ec.fieldContext_Part_Ref(ctx, field)
			case "String":
				return ec.fieldContext_Part_String(ctx, field)
			case "ReleaseInfo":
				return ec.fieldContext_Part_ReleaseInfo(ctx, field)
			case "AvailableAt":
				return ec.fieldContext_Part_AvailableAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Part", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_PartList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ReleaseGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ReleaseGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ReleaseGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto3.Release); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/release/dto.Release`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto3.Release)
	fc.Result = res
	return ec.marshalNRelease2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ReleaseGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Release_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_Release_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_Release_Description(ctx, field)
			case "Releasables":
				return ec.fieldContext_Release_Releasables(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Release", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ReleaseGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ReleaseList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ReleaseList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ReleaseList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "releases_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive0, permission)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto3.Release); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/release/dto.Release`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto3.Release)
	fc.Result = res
	return ec.marshalNRelease2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ReleaseList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Release_ID(ctx, field)
			case "ReleaseDate":
				return ec.fieldContext_Release_ReleaseDate(ctx, field)
			case "Description":
				return ec.fieldContext_Release_Description(ctx, field)
			case "Releasables":
				return ec.fieldContext_Release_Releasables(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Release", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_UserGet(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_UserGet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UserGet(rctx, fc.Args["id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, nil, directive0, protectedFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_UserGet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_UserGet_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_UserGetSelf(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_UserGetSelf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UserGetSelf(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, nil, directive0, protectedFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_read_self")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_UserGetSelf(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_UserList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_UserList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UserList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			protectedFields, err := ec.unmarshalNString2ᚕstringᚄ(ctx, []interface{}{"Email", "Roles", "Permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Protect == nil {
				return nil, errors.New("directive protect is not implemented")
			}
			return ec.directives.Protect(ctx, nil, directive0, protectedFields)
		}
		directive2 := func(ctx context.Context) (interface{}, error) {
			permission, err := ec.unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx, "users_read")
			if err != nil {
				return nil, err
			}
			if ec.directives.Permission == nil {
				return nil, errors.New("directive permission is not implemented")
			}
			return ec.directives.Permission(ctx, nil, directive1, permission)
		}

		tmp, err := directive2(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*dto4.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*waterfall-backend/internal/modules/domain/user/dto.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto4.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_UserList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "CreatedAt":
				return ec.fieldContext_User_CreatedAt(ctx, field)
			case "UpdatedAt":
				return ec.fieldContext_User_UpdatedAt(ctx, field)
			case "DeletedAt":
				return ec.fieldContext_User_DeletedAt(ctx, field)
			case "Email":
				return ec.fieldContext_User_Email(ctx, field)
			case "Fullname":
				return ec.fieldContext_User_Fullname(ctx, field)
			case "Username":
				return ec.fieldContext_User_Username(ctx, field)
			case "Score":
				return ec.fieldContext_User_Score(ctx, field)
			case "Roles":
				return ec.fieldContext_User_Roles(ctx, field)
			case "Attachments":
				return ec.fieldContext_User_Attachments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Release_ID(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Release_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Release_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Release",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Release_ReleaseDate(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Release_ReleaseDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Release_ReleaseDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Release",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Release_Description(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Release_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Release_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Release",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Release_Releasables(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Release_Releasables(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Releasables, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]dto3.Releasable)
	fc.Result = res
	return ec.marshalNReleasable2ᚕwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleasableᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Release_Releasables(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Release",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseInfo_ID(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReleaseInfo_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReleaseInfo_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseInfo_ReleaseDate(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReleaseInfo_ReleaseDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReleaseInfo_ReleaseDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ReleaseInfo_Description(ctx context.Context, field graphql.CollectedField, obj *dto3.Release) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ReleaseInfo_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ReleaseInfo_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ReleaseInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_ID(ctx context.Context, field graphql.CollectedField, obj *dto4.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(roles.Type)
	fc.Result = res
	return ec.marshalNRoleType2waterfallᚑbackendᚋinternalᚋmodelsᚋrolesᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoleType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_Description(ctx context.Context, field graphql.CollectedField, obj *dto4.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Role_ReleaseDelay(ctx context.Context, field graphql.CollectedField, obj *dto4.Role) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Role_ReleaseDelay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Role().ReleaseDelay(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Role_ReleaseDelay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Role",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_ID(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uuid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_CreatedAt(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_CreatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_CreatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_UpdatedAt(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_UpdatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNDateTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_UpdatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_DeletedAt(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_DeletedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalODateTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_DeletedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Email(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Fullname(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Fullname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fullname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Fullname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Username(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Score(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Score(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Roles(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Roles(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto4.Role)
	fc.Result = res
	return ec.marshalNRole2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRoleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_Role_ID(ctx, field)
			case "Description":
				return ec.fieldContext_Role_Description(ctx, field)
			case "ReleaseDelay":
				return ec.fieldContext_Role_ReleaseDelay(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Role", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Attachments(ctx context.Context, field graphql.CollectedField, obj *dto4.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Attachments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Attachments(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*dto5.File)
	fc.Result = res
	return ec.marshalNFile2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋservicesᚋfsᚋdtoᚐFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Attachments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_File_ID(ctx, field)
			case "Filename":
				return ec.fieldContext_File_Filename(ctx, field)
			case "MIMEType":
				return ec.fieldContext_File_MIMEType(ctx, field)
			case "Description":
				return ec.fieldContext_File_Description(ctx, field)
			case "CreatorID":
				return ec.fieldContext_File_CreatorID(ctx, field)
			case "ObjectRef":
				return ec.fieldContext_File_ObjectRef(ctx, field)
			case "Type":
				return ec.fieldContext_File_Type(ctx, field)
			case "Temp":
				return ec.fieldContext_File_Temp(ctx, field)
			case "SequenceNumber":
				return ec.fieldContext_File_SequenceNumber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputChapterCreate(ctx context.Context, obj interface{}) (dto.ChapterCreate, error) {
	var it dto.ChapterCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Number", "Title", "PartID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Number"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Number = data
		case "Title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "PartID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("PartID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartUuid = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChapterTextCreate(ctx context.Context, obj interface{}) (dto.ChapterTextCreate, error) {
	var it dto.ChapterTextCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ChapterID", "Text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ChapterID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ChapterID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChapterUuid = data
		case "Text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChapterTextUpdate(ctx context.Context, obj interface{}) (dto.ChapterTextUpdate, error) {
	var it dto.ChapterTextUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChapterUpdate(ctx context.Context, obj interface{}) (dto.ChapterUpdate, error) {
	var it dto.ChapterUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Number", "Title", "PartID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Number"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Number = data
		case "Title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "PartID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("PartID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PartUuid = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommentCreate(ctx context.Context, obj interface{}) (dto1.CommentCreate, error) {
	var it dto1.CommentCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Text", "ParentID", "ChapterID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "ParentID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ParentID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentUuid = data
		case "ChapterID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ChapterID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChapterUuid = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommentUpdate(ctx context.Context, obj interface{}) (dto1.CommentUpdate, error) {
	var it dto1.CommentUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputObjectRefInput(ctx context.Context, obj interface{}) (models1.ObjectRef, error) {
	var it models1.ObjectRef
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Type", "Ref"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Type"))
			data, err := ec.unmarshalNObjectType2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "Ref":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Ref"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ref = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOptionalID(ctx context.Context, obj interface{}) (optional.Variable[string], error) {
	var it optional.Variable[string]
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OptionalID().Value(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOptionalInt(ctx context.Context, obj interface{}) (optional.Variable[int], error) {
	var it optional.Variable[int]
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OptionalInt().Value(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOptionalString(ctx context.Context, obj interface{}) (optional.Variable[string], error) {
	var it optional.Variable[string]
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OptionalString().Value(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOptionalStringSlice(ctx context.Context, obj interface{}) (optional.Variable[[]string], error) {
	var it optional.Variable[[]string]
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.OptionalStringSlice().Value(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPartCreate(ctx context.Context, obj interface{}) (dto2.PartCreate, error) {
	var it dto2.PartCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Number", "Title", "Annotation"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Number"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Number = data
		case "Title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "Annotation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Annotation"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotation = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPartUpdate(ctx context.Context, obj interface{}) (dto2.PartUpdate, error) {
	var it dto2.PartUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Number", "Title", "Annotation"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Number":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Number"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Number = data
		case "Title":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Title"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "Annotation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Annotation"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Annotation = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReleaseCreate(ctx context.Context, obj interface{}) (dto3.ReleaseCreate, error) {
	var it dto3.ReleaseCreate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ReleaseDate", "Description", "ObjectRefs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ReleaseDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ReleaseDate"))
			data, err := ec.unmarshalNDateTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseDate = data
		case "Description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "ObjectRefs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ObjectRefs"))
			data, err := ec.unmarshalNObjectRefInput2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRefᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ObjectRefs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputReleaseUpdate(ctx context.Context, obj interface{}) (dto3.ReleaseUpdate, error) {
	var it dto3.ReleaseUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ReleaseDate", "Description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ReleaseDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ReleaseDate"))
			data, err := ec.unmarshalNDateTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseDate = data
		case "Description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserUpdate(ctx context.Context, obj interface{}) (dto4.UserUpdate, error) {
	var it dto4.UserUpdate
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Fullname", "Username"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Fullname":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Fullname"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserUpdate().Fullname(ctx, &it, data); err != nil {
				return it, err
			}
		case "Username":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Username"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.UserUpdate().Username(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Releasable(ctx context.Context, sel ast.SelectionSet, obj dto3.Releasable) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *dto.Chapter:
		if obj == nil {
			return graphql.Null
		}
		return ec._Chapter(ctx, sel, obj)
	case *dto2.Part:
		if obj == nil {
			return graphql.Null
		}
		return ec._Part(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var chapterImplementors = []string{"Chapter", "Releasable"}

func (ec *executionContext) _Chapter(ctx context.Context, sel ast.SelectionSet, obj *dto.Chapter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chapterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Chapter")
		case "ID":
			out.Values[i] = ec._Chapter_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Number":
			out.Values[i] = ec._Chapter_Number(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Title":
			out.Values[i] = ec._Chapter_Title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Part":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_Part(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Text":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_Text(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Attachments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_Attachments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Comments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_Comments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "NextID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_NextID(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "PrevID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_PrevID(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Ref":
			out.Values[i] = ec._Chapter_Ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "String":
			out.Values[i] = ec._Chapter_String(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ReleaseInfo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_ReleaseInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "AvailableAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Chapter_AvailableAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var chapterTextImplementors = []string{"ChapterText"}

func (ec *executionContext) _ChapterText(ctx context.Context, sel ast.SelectionSet, obj *dto.ChapterText) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, chapterTextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChapterText")
		case "ID":
			out.Values[i] = ec._ChapterText_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterID":
			out.Values[i] = ec._ChapterText_ChapterID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Text":
			out.Values[i] = ec._ChapterText_Text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commentImplementors = []string{"Comment"}

func (ec *executionContext) _Comment(ctx context.Context, sel ast.SelectionSet, obj *dto1.Comment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Comment")
		case "ID":
			out.Values[i] = ec._Comment_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "CreatedAt":
			out.Values[i] = ec._Comment_CreatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "UpdatedAt":
			out.Values[i] = ec._Comment_UpdatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Text":
			out.Values[i] = ec._Comment_Text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Author":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Comment_Author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ParentID":
			out.Values[i] = ec._Comment_ParentID(ctx, field, obj)
		case "ChapterID":
			out.Values[i] = ec._Comment_ChapterID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *dto5.File) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "ID":
			out.Values[i] = ec._File_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Filename":
			out.Values[i] = ec._File_Filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "MIMEType":
			out.Values[i] = ec._File_MIMEType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Description":
			out.Values[i] = ec._File_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CreatorID":
			out.Values[i] = ec._File_CreatorID(ctx, field, obj)
		case "ObjectRef":
			out.Values[i] = ec._File_ObjectRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Type":
			out.Values[i] = ec._File_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Temp":
			out.Values[i] = ec._File_Temp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "SequenceNumber":
			out.Values[i] = ec._File_SequenceNumber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "ping":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ping(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterTextCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterTextCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterTextUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterTextUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ChapterTextDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ChapterTextDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CommentCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CommentCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CommentUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CommentUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CommentDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CommentDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FilesMakeNotTemp":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_FilesMakeNotTemp(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FilesDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_FilesDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FilesReorder":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_FilesReorder(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PartCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_PartCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PartUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_PartUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PartDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_PartDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ReleaseCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ReleaseCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ReleaseUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ReleaseUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ReleaseDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ReleaseDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ScheduleReleaseCreate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ScheduleReleaseCreate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserUpdateSelf":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserUpdateSelf(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserUpdate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserUpdate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserDeleteSelf":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserDeleteSelf(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserDelete":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserDelete(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserAddRole":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserAddRole(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "UserRemoveRole":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UserRemoveRole(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var objectRefImplementors = []string{"ObjectRef"}

func (ec *executionContext) _ObjectRef(ctx context.Context, sel ast.SelectionSet, obj *models1.ObjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, objectRefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ObjectRef")
		case "Type":
			out.Values[i] = ec._ObjectRef_Type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Ref":
			out.Values[i] = ec._ObjectRef_Ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var partImplementors = []string{"Part", "Releasable"}

func (ec *executionContext) _Part(ctx context.Context, sel ast.SelectionSet, obj *dto2.Part) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, partImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Part")
		case "ID":
			out.Values[i] = ec._Part_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Number":
			out.Values[i] = ec._Part_Number(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Title":
			out.Values[i] = ec._Part_Title(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Annotation":
			out.Values[i] = ec._Part_Annotation(ctx, field, obj)
		case "Chapters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Part_Chapters(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Ref":
			out.Values[i] = ec._Part_Ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "String":
			out.Values[i] = ec._Part_String(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ReleaseInfo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Part_ReleaseInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "AvailableAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Part_AvailableAt(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "ping":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ping(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterNextID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterNextID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterPrevID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterPrevID(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterFirstID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterFirstID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterLastAvailableID":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterLastAvailableID(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterLastAvailableAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterLastAvailableAt(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ChapterTextGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ChapterTextGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "CommentGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_CommentGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "CommentListByChapter":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_CommentListByChapter(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "PartGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_PartGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "PartList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_PartList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ReleaseGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ReleaseGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ReleaseList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ReleaseList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "UserGet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_UserGet(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "UserGetSelf":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_UserGetSelf(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "UserList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_UserList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var releaseImplementors = []string{"Release"}

func (ec *executionContext) _Release(ctx context.Context, sel ast.SelectionSet, obj *dto3.Release) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, releaseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Release")
		case "ID":
			out.Values[i] = ec._Release_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ReleaseDate":
			out.Values[i] = ec._Release_ReleaseDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Description":
			out.Values[i] = ec._Release_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Releasables":
			out.Values[i] = ec._Release_Releasables(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var releaseInfoImplementors = []string{"ReleaseInfo"}

func (ec *executionContext) _ReleaseInfo(ctx context.Context, sel ast.SelectionSet, obj *dto3.Release) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, releaseInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ReleaseInfo")
		case "ID":
			out.Values[i] = ec._ReleaseInfo_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ReleaseDate":
			out.Values[i] = ec._ReleaseInfo_ReleaseDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Description":
			out.Values[i] = ec._ReleaseInfo_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roleImplementors = []string{"Role"}

func (ec *executionContext) _Role(ctx context.Context, sel ast.SelectionSet, obj *dto4.Role) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Role")
		case "ID":
			out.Values[i] = ec._Role_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Description":
			out.Values[i] = ec._Role_Description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ReleaseDelay":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Role_ReleaseDelay(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *dto4.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "ID":
			out.Values[i] = ec._User_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "CreatedAt":
			out.Values[i] = ec._User_CreatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "UpdatedAt":
			out.Values[i] = ec._User_UpdatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "DeletedAt":
			out.Values[i] = ec._User_DeletedAt(ctx, field, obj)
		case "Email":
			out.Values[i] = ec._User_Email(ctx, field, obj)
		case "Fullname":
			out.Values[i] = ec._User_Fullname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Username":
			out.Values[i] = ec._User_Username(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Score":
			out.Values[i] = ec._User_Score(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "Roles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Roles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "Attachments":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Attachments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNChapter2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx context.Context, sel ast.SelectionSet, v dto.Chapter) graphql.Marshaler {
	return ec._Chapter(ctx, sel, &v)
}

func (ec *executionContext) marshalNChapter2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto.Chapter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChapter2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNChapter2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapter(ctx context.Context, sel ast.SelectionSet, v *dto.Chapter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Chapter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChapterCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterCreate(ctx context.Context, v interface{}) (dto.ChapterCreate, error) {
	res, err := ec.unmarshalInputChapterCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChapterText2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx context.Context, sel ast.SelectionSet, v dto.ChapterText) graphql.Marshaler {
	return ec._ChapterText(ctx, sel, &v)
}

func (ec *executionContext) marshalNChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx context.Context, sel ast.SelectionSet, v *dto.ChapterText) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChapterText(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChapterTextCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterTextCreate(ctx context.Context, v interface{}) (dto.ChapterTextCreate, error) {
	res, err := ec.unmarshalInputChapterTextCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChapterTextUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterTextUpdate(ctx context.Context, v interface{}) (dto.ChapterTextUpdate, error) {
	res, err := ec.unmarshalInputChapterTextUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNChapterUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterUpdate(ctx context.Context, v interface{}) (dto.ChapterUpdate, error) {
	res, err := ec.unmarshalInputChapterUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNComment2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx context.Context, sel ast.SelectionSet, v dto1.Comment) graphql.Marshaler {
	return ec._Comment(ctx, sel, &v)
}

func (ec *executionContext) marshalNComment2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto1.Comment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNComment2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNComment2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐComment(ctx context.Context, sel ast.SelectionSet, v *dto1.Comment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Comment(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCommentCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentCreate(ctx context.Context, v interface{}) (dto1.CommentCreate, error) {
	res, err := ec.unmarshalInputCommentCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCommentUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋcommentᚋdtoᚐCommentUpdate(ctx context.Context, v interface{}) (dto1.CommentUpdate, error) {
	res, err := ec.unmarshalInputCommentUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDateTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDateTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNFile2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋservicesᚋfsᚋdtoᚐFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto5.File) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋservicesᚋfsᚋdtoᚐFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFile2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋservicesᚋfsᚋdtoᚐFile(ctx context.Context, sel ast.SelectionSet, v *dto5.File) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFileType2waterfallᚑbackendᚋinternalᚋmodelsᚋfilesᚐType(ctx context.Context, v interface{}) (files.Type, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := files.Type(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFileType2waterfallᚑbackendᚋinternalᚋmodelsᚋfilesᚐType(ctx context.Context, sel ast.SelectionSet, v files.Type) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNObjectRef2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx context.Context, sel ast.SelectionSet, v models1.ObjectRef) graphql.Marshaler {
	return ec._ObjectRef(ctx, sel, &v)
}

func (ec *executionContext) marshalNObjectRef2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx context.Context, sel ast.SelectionSet, v *models1.ObjectRef) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ObjectRef(ctx, sel, v)
}

func (ec *executionContext) unmarshalNObjectRefInput2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRefᚄ(ctx context.Context, v interface{}) ([]*models1.ObjectRef, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*models1.ObjectRef, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNObjectRefInput2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNObjectRefInput2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚐObjectRef(ctx context.Context, v interface{}) (*models1.ObjectRef, error) {
	res, err := ec.unmarshalInputObjectRefInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNObjectType2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectType(ctx context.Context, v interface{}) (models1.ObjectType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := models1.ObjectType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNObjectType2waterfallᚑbackendᚋinternalᚋmodelsᚐObjectType(ctx context.Context, sel ast.SelectionSet, v models1.ObjectType) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPart2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx context.Context, sel ast.SelectionSet, v dto2.Part) graphql.Marshaler {
	return ec._Part(ctx, sel, &v)
}

func (ec *executionContext) marshalNPart2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto2.Part) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPart2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPart(ctx context.Context, sel ast.SelectionSet, v *dto2.Part) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Part(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPartCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartCreate(ctx context.Context, v interface{}) (dto2.PartCreate, error) {
	res, err := ec.unmarshalInputPartCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPartUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋpartᚋdtoᚐPartUpdate(ctx context.Context, v interface{}) (dto2.PartUpdate, error) {
	res, err := ec.unmarshalInputPartUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNReleasable2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleasable(ctx context.Context, sel ast.SelectionSet, v dto3.Releasable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Releasable(ctx, sel, v)
}

func (ec *executionContext) marshalNReleasable2ᚕwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleasableᚄ(ctx context.Context, sel ast.SelectionSet, v []dto3.Releasable) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNReleasable2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleasable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRelease2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx context.Context, sel ast.SelectionSet, v dto3.Release) graphql.Marshaler {
	return ec._Release(ctx, sel, &v)
}

func (ec *executionContext) marshalNRelease2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto3.Release) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRelease2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRelease2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx context.Context, sel ast.SelectionSet, v *dto3.Release) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Release(ctx, sel, v)
}

func (ec *executionContext) unmarshalNReleaseCreate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseCreate(ctx context.Context, v interface{}) (dto3.ReleaseCreate, error) {
	res, err := ec.unmarshalInputReleaseCreate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNReleaseInfo2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx context.Context, sel ast.SelectionSet, v dto3.Release) graphql.Marshaler {
	return ec._ReleaseInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx context.Context, sel ast.SelectionSet, v *dto3.Release) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ReleaseInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNReleaseUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐReleaseUpdate(ctx context.Context, v interface{}) (dto3.ReleaseUpdate, error) {
	res, err := ec.unmarshalInputReleaseUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRoleᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto4.Role) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRole2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRole2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐRole(ctx context.Context, sel ast.SelectionSet, v *dto4.Role) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Role(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRoleType2waterfallᚑbackendᚋinternalᚋmodelsᚋrolesᚐType(ctx context.Context, v interface{}) (roles.Type, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := roles.Type(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoleType2waterfallᚑbackendᚋinternalᚋmodelsᚋrolesᚐType(ctx context.Context, sel ast.SelectionSet, v roles.Type) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx context.Context, sel ast.SelectionSet, v dto4.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*dto4.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUser(ctx context.Context, sel ast.SelectionSet, v *dto4.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserUpdate2waterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋuserᚋdtoᚐUserUpdate(ctx context.Context, v interface{}) (dto4.UserUpdate, error) {
	res, err := ec.unmarshalInputUserUpdate(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOChapterText2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋchapterᚋdtoᚐChapterText(ctx context.Context, sel ast.SelectionSet, v *dto.ChapterText) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ChapterText(ctx, sel, v)
}

func (ec *executionContext) unmarshalODateTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx context.Context, v interface{}) (*permissions.Type, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := permissions.Type(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPermissionType2ᚖwaterfallᚑbackendᚋinternalᚋmodelsᚋpermissionsᚐType(ctx context.Context, sel ast.SelectionSet, v *permissions.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOReleaseInfo2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋdomainᚋreleaseᚋdtoᚐRelease(ctx context.Context, sel ast.SelectionSet, v *dto3.Release) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ReleaseInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSortOrder2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋioᚋgraphqlᚋmodelsᚐSortOrder(ctx context.Context, v interface{}) (*models.SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.SortOrder)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortOrder2ᚖwaterfallᚑbackendᚋinternalᚋmodulesᚋioᚋgraphqlᚋmodelsᚐSortOrder(ctx context.Context, sel ast.SelectionSet, v *models.SortOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOUint2ᚖuint(ctx context.Context, v interface{}) (*uint, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint2ᚖuint(ctx context.Context, sel ast.SelectionSet, v *uint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
