package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"sort"
	"time"
	dto1 "waterfall-backend/internal/modules/domain/chapter/dto"
	"waterfall-backend/internal/modules/domain/part/dto"
	dto2 "waterfall-backend/internal/modules/domain/release/dto"
	"waterfall-backend/internal/modules/io/graphql/generated"
	"waterfall-backend/internal/modules/io/graphql/models"
)

// PartCreate is the resolver for the PartCreate field.
func (r *mutationResolver) PartCreate(ctx context.Context, part dto.PartCreate) (*dto.Part, error) {
	created, err := r.services.Part.Create(ctx, &part)
	if err != nil {
		return nil, err
	}

	return created, nil
}

// PartUpdate is the resolver for the PartUpdate field.
func (r *mutationResolver) PartUpdate(ctx context.Context, id string, part dto.PartUpdate) (*dto.Part, error) {
	updated, err := r.services.Part.Update(ctx, id, &part)
	if err != nil {
		return nil, err
	}

	return updated, nil
}

// PartDelete is the resolver for the PartDelete field.
func (r *mutationResolver) PartDelete(ctx context.Context, id string) (string, error) {
	err := r.services.Part.Delete(ctx, id)
	if err != nil {
		return "", err
	}

	return id, nil
}

// Chapters is the resolver for the Chapters field.
func (r *partResolver) Chapters(ctx context.Context, obj *dto.Part, sortOrder *models.SortOrder) ([]*dto1.Chapter, error) {
	chapters, err := r.services.Part.ListChaptersByUuid(ctx, obj.Uuid)
	if err != nil {
		return nil, err
	}

	// TODO: перенести сортировку на уровень БД
	if sortOrder != nil {
		switch *sortOrder {
		case models.SortOrderAsc:
			sort.Slice(chapters, func(i, j int) bool {
				return chapters[i].Number < chapters[j].Number
			})
		case models.SortOrderDesc:
			sort.Slice(chapters, func(i, j int) bool {
				return chapters[i].Number > chapters[j].Number
			})
		}
	}

	return chapters, nil
}

// ReleaseInfo is the resolver for the ReleaseInfo field.
func (r *partResolver) ReleaseInfo(ctx context.Context, obj *dto.Part) (*dto2.Release, error) {
	if obj.ReleaseUuid == nil {
		return nil, nil
	}

	return r.services.Release.GetInfoByUuid(ctx, *obj.ReleaseUuid)
}

// AvailableAt is the resolver for the AvailableAt field.
func (r *partResolver) AvailableAt(ctx context.Context, obj *dto.Part) (*time.Time, error) {
	if obj.ReleaseUuid == nil {
		return nil, nil
	}

	return r.services.Release.GetAvailableAtByUuid(ctx, *obj.ReleaseUuid)
}

// PartGet is the resolver for the PartGet field.
func (r *queryResolver) PartGet(ctx context.Context, id string) (*dto.Part, error) {
	part, err := r.services.Part.GetByUuid(ctx, id)
	if err != nil {
		return nil, err
	}

	return part, nil
}

// PartList is the resolver for the PartList field.
func (r *queryResolver) PartList(ctx context.Context, sortOrder *models.SortOrder) ([]*dto.Part, error) {
	parts, err := r.services.Part.List(ctx)
	if err != nil {
		return nil, err
	}

	// TODO: перенести сортировку на уровень БД
	if sortOrder != nil {
		switch *sortOrder {
		case models.SortOrderAsc:
			sort.Slice(parts, func(i, j int) bool {
				return parts[i].Number < parts[j].Number
			})
		case models.SortOrderDesc:
			sort.Slice(parts, func(i, j int) bool {
				return parts[i].Number > parts[j].Number
			})
		}
	}

	return parts, nil
}

// Part returns generated.PartResolver implementation.
func (r *Resolver) Part() generated.PartResolver { return &partResolver{r} }

type partResolver struct{ *Resolver }
