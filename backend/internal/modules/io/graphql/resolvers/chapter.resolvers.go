package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"errors"
	"fmt"
	"time"
	"waterfall-backend/internal/constants/err_const"
	"waterfall-backend/internal/models"
	"waterfall-backend/internal/modules/domain/chapter/dto"
	dto4 "waterfall-backend/internal/modules/domain/comment/dto"
	dto1 "waterfall-backend/internal/modules/domain/part/dto"
	dto2 "waterfall-backend/internal/modules/domain/release/dto"
	"waterfall-backend/internal/modules/io/graphql/generated"
	dto3 "waterfall-backend/internal/modules/services/fs/dto"
)

// Part is the resolver for the Part field.
func (r *chapterResolver) Part(ctx context.Context, obj *dto.Chapter) (*dto1.Part, error) {
	part, err := r.services.Part.GetByUuid(ctx, obj.PartUuid)
	if err != nil {
		return nil, err
	}

	return part, nil
}

// Text is the resolver for the Text field.
func (r *chapterResolver) Text(ctx context.Context, obj *dto.Chapter) (*dto.ChapterText, error) {
	chapterText, err := r.services.ChapterText.GetByChapterUuid(ctx, obj.Uuid)
	if err != nil {
		if errors.Is(err, err_const.ErrNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return chapterText, nil
}

// Attachments is the resolver for the Attachments field.
func (r *chapterResolver) Attachments(ctx context.Context, obj *dto.Chapter) ([]*dto3.File, error) {
	return r.services.FileStorage.ListNotTempByObjectRef(ctx, &models.ObjectRef{
		Type: models.ObjectTypeChapters,
		Ref:  obj.Uuid,
	})
}

// Comments is the resolver for the Comments field.
func (r *chapterResolver) Comments(ctx context.Context, obj *dto.Chapter) ([]*dto4.Comment, error) {
	return r.services.Comment.ListByChapter(ctx, obj.Uuid)
}

// NextID is the resolver for the NextID field.
func (r *chapterResolver) NextID(ctx context.Context, obj *dto.Chapter) (*string, error) {
	return r.services.Chapter.NextUuid(ctx, obj.Uuid)
}

// PrevID is the resolver for the PrevID field.
func (r *chapterResolver) PrevID(ctx context.Context, obj *dto.Chapter) (*string, error) {
	return r.services.Chapter.PrevUuid(ctx, obj.Uuid)
}

// ReleaseInfo is the resolver for the ReleaseInfo field.
func (r *chapterResolver) ReleaseInfo(ctx context.Context, obj *dto.Chapter) (*dto2.Release, error) {
	if obj.ReleaseUuid == nil {
		return nil, nil
	}

	return r.services.Release.GetInfoByUuid(ctx, *obj.ReleaseUuid)
}

// AvailableAt is the resolver for the AvailableAt field.
func (r *chapterResolver) AvailableAt(ctx context.Context, obj *dto.Chapter) (*time.Time, error) {
	if obj.ReleaseUuid == nil {
		return nil, nil
	}

	return r.services.Release.GetAvailableAtByUuid(ctx, *obj.ReleaseUuid)
}

// ChapterCreate is the resolver for the ChapterCreate field.
func (r *mutationResolver) ChapterCreate(ctx context.Context, chapter dto.ChapterCreate) (*dto.Chapter, error) {
	created, err := r.services.Chapter.Create(ctx, &chapter)
	if err != nil {
		return nil, err
	}

	return created, nil
}

// ChapterUpdate is the resolver for the ChapterUpdate field.
func (r *mutationResolver) ChapterUpdate(ctx context.Context, id string, chapter dto.ChapterUpdate) (*dto.Chapter, error) {
	updated, err := r.services.Chapter.Update(ctx, id, &chapter)
	if err != nil {
		return nil, err
	}

	return updated, nil
}

// ChapterDelete is the resolver for the ChapterDelete field.
func (r *mutationResolver) ChapterDelete(ctx context.Context, id string) (string, error) {
	err := r.services.Chapter.Delete(ctx, id)
	if err != nil {
		return "", err
	}

	return id, nil
}

// ChapterGet is the resolver for the ChapterGet field.
func (r *queryResolver) ChapterGet(ctx context.Context, id string) (*dto.Chapter, error) {
	chapter, err := r.services.Chapter.GetByUuid(ctx, id)
	if err != nil {
		return nil, err
	}

	return chapter, nil
}

// ChapterList is the resolver for the ChapterList field.
func (r *queryResolver) ChapterList(ctx context.Context) ([]*dto.Chapter, error) {
	chapters, err := r.services.Chapter.List(ctx)
	if err != nil {
		return nil, err
	}

	return chapters, nil
}

// ChapterNextID is the resolver for the ChapterNextID field.
func (r *queryResolver) ChapterNextID(ctx context.Context, id string) (*string, error) {
	return r.services.Chapter.NextUuid(ctx, id)
}

// ChapterPrevID is the resolver for the ChapterPrevID field.
func (r *queryResolver) ChapterPrevID(ctx context.Context, id string) (*string, error) {
	return r.services.Chapter.PrevUuid(ctx, id)
}

// ChapterFirstID is the resolver for the ChapterFirstID field.
func (r *queryResolver) ChapterFirstID(ctx context.Context) (string, error) {
	return r.services.Chapter.FirstUuid(ctx)
}

// ChapterLastAvailableID is the resolver for the ChapterLastAvailableID field.
func (r *queryResolver) ChapterLastAvailableID(ctx context.Context) (string, error) {
	return r.services.Chapter.LastAvailableUuid(ctx)
}

// ChapterLastAvailableAt is the resolver for the ChapterLastAvailableAt field.
func (r *queryResolver) ChapterLastAvailableAt(ctx context.Context) (*time.Time, error) {
	uuid, err := r.services.Chapter.LastAvailableUuid(ctx)
	if err != nil {
		return nil, err
	}

	chapter, err := r.services.Chapter.GetByUuid(ctx, uuid)
	if err != nil {
		return nil, err
	}

	if chapter.ReleaseUuid == nil {
		return nil, fmt.Errorf("у главы %s нет релиза", uuid)
	}

	return r.services.Release.GetAvailableAtByUuid(ctx, *chapter.ReleaseUuid)
}

// Chapter returns generated.ChapterResolver implementation.
func (r *Resolver) Chapter() generated.ChapterResolver { return &chapterResolver{r} }

type chapterResolver struct{ *Resolver }
